# ChordNetwork
P2P中的弦网络结构分析及其Python实现
![](http://ww4.sinaimg.cn/large/006tNbRwly1ff6s4pa3wsj312k0w8mz3.jpg)

---

> 网络是群体的象征。由此产生的群组织——分布式系统——将自我撒布在整个网络，以致于没有一部分能说「我就是我」。无数的个体思维聚在一起，形成了无可逆转的社会性。它所表达的既包含了计算机的逻辑，又包含了大自然的逻辑，进而展现出一种超越理解能力的力量。

> ——互联网预言巨著《失控：机器、社会与经济的新生物学》第二章 蜂群思维

## 问题引入
为什么需要P2P？

1. 分布式节省服务器开销
2. 避免互联网企业掌握用户隐私
3. 符合去中心化的互联网前景

---

什么是`Chord Network Model`弦网络模型？

1. 建立在现有物理网络上的逻辑**网络**
2. 分布式哈希表的**数据结构**
3. 幂次逼近查找的**算法**

---

如何在研究层面上模拟这个模型？

1. 脱离网络，本地模拟
2. 单程序模拟，避免干扰，便于从全局角度绘图
3. 单线程（逻辑模拟）或多线程（时序模拟）

## Python实现

- 项目源码：`https://github.com/rikumi/ChordNetwork`
- 运行平台：`Python 3.5`及以上（iOS端`Pythonista`兼容）
- 利用框架：`networkx` `matplotlib`

## 效果初步演示

### 文件结构（P2P的性质）

1. 纯P2P网络应当只存在节点程序，不依附于任何节点的程序不存在
2. 所有逻辑代码都在节点类中
3. 所有在节点类外面的代码都是用于模拟操作或绘制网络图
4. 实际生产中，往往采用P2P与C/S结构相结合，例如迅雷既有中心服务器（用于发布官方页面、新闻、客户端更新等），又有P2P文件共享（用于加速下载）

### 程序全局量
- `id_length`：地址二进制位数，网络最大容量的对数
- `capacity`：网络最大容量

### 节点成员量
- `address`：粗略表示节点物理地址的字符串
- `id`：根据物理地址计算出来的逻辑地址，节点按照`id`顺时针排序
- `resources`：当前节点存储数据的哈希表
- `successor`：直接后继指针
- `predecessor`：直接前驱指针
- `finger`：幂次查找表（第1、2、4、8、...个后继的指针）
- `successors`：缓存的一些后继指针，用于后继掉线时修复网络连通性
- `message_queue`：消息队列，用于每个节点定期向后继发送消息（心跳包）

## 逻辑原理详解

### 两种映射
- 节点映射：根据节点地址名，可直接算出节点`id`，知道节点在环内的顺序
- 资源映射：根据资源文件名，可直接算出资源`id`，知道资源应该存储的节点位置

### 查找操作
多数其他操作的基础

- 什么是幂次逼近查找？

假设环中`节点数＝环容量`，知道资源`key` -> 知道资源对应的节点`id` -> 找到资源

例如：`13 = 8 + 4 + 1` `15 = 8 + 4 + 2 + 1`
`O(lg(node_count))`

---

若考虑`节点数＜环容量`的情况，如何设计？

1. 节点存储自己的数据
2. 节点帮助它的前驱与它之间的空缺位置存储数据
3. 按照以上规则设计`finger`幂次表的更新规则
4. 有何缺陷？

### 我们忽略了什么？
这里面其实有一个大坑

### 节点的比较
- 环中节点的比较，是简单的比较大小吗？

### 插入节点

- (1) 查找符合条件的后继
- (2) 新节点主张加入网络，但是其他节点并不知情

![](http://ww1.sinaimg.cn/large/006tNbRwly1ff6sp38meuj312o0u8401.jpg)

---

- (3) 新节点定期发送心跳包，后继收到心跳包，发现新节点是新的有效前驱，调整前驱
- (4) 新节点的前驱定期检查其（旧）后继的（新）前驱，发现新节点是新的有效后继，调整后继
- (5) 新节点的前驱向新节点发送心跳包，新节点调整前驱

---

![](http://ww4.sinaimg.cn/large/006tNbRwly1ff6spsv01rj312o0pw3zt.jpg)

大约花费3个时间周期

### 节点掉线

![](http://ww4.sinaimg.cn/large/006tNbRwly1ff6sqcd7f4j312w0rqtaf.jpg)

---

- (1) 节点进入掉线状态，无法被访问

![](http://ww4.sinaimg.cn/large/006tNbRwly1ff6sqkvnkgj312e0r0myl.jpg)

---

- (2) 前驱发送心跳包失败，认为其后继掉线，并从后继缓存表中找到下一个有效后继作为替换
- (3) 前驱向新后继发送心跳包
- (4) 新后继收到心跳包，发现旧前驱掉线，更换新前驱

---

![](http://ww1.sinaimg.cn/large/006tNbRwly1ff6sqv0tv2j312q0ri0u8.jpg)

大约花费2个时间周期

### 节点友好下线
可以直接沿用掉线的方法，但友好下线可以提前通知邻居：

1. 节点通知前驱，修改它的后继为自己的后继
2. 节点同时通知后继，修改它的前驱为自己的前驱
3. 节点断开连接

大约花费1个时间周期

### 添加数据文件

1. 通过文件名计算`id`
2. 查找符合条件的节点
3. 将文件存入对应节点的哈希表

### 读取数据文件

1. 通过文件名计算`id`
2. 查找符合条件的节点
3. 从对应节点的哈希表取数据
4. 若取不到数据，顺时针向后转发一圈（为什么？）

## 实现上的一些细节

### 定时操作

- 每个节点需要有下列定时操作：

1. 检查后继是否掉线，若掉线，用下一个后继代替
2. 检查后继的前驱是否为新后继
3. 以上两种情况下需要更新后继表和`finger`表
4. 给后继发送心跳包
5. 接收心跳包，检查消息发送者是否为有效新前驱

### 定时操作的实现

1. 我们在`main`驱动程序执行每次插入操作、掉线操作后，都调用了一个静态函数
2. 单线程设置下，该函数负责遍历所有节点，模拟它们各自的定时操作
3. 多线程设置下，各个节点一旦初始化就会开启定时线程，因此该函数只负责令主线程`sleep`一个时间周期，允许网络有处理插入删除操作的时间

## 完整模拟展示

1. 地址位数6，最大容纳64个节点
2. 每一个时间周期都会插入一个新节点
3. 每5个时间周期插入的新节点都模拟断线
4. 每插入一个新节点后，在网络中存放一个文件
5. 插入完所有节点后，在网络中再存放两个文件
6. 测试读取插入完节点前存放的文件
7. 测试读取插入完节点后存放的文件
8. 测试读取不存在的文件
9. 用单线程和多线程分别演示
