# Git快速上手

## 关于Git

Git是新一代的版本控制系统（VCS, Version Control System）和源代码管理器（SCM, Source Code Manager），它利用内置的轻量级文件系统，实现代码库的版本管理、分支管理、在线同步、多人协作等功能。Git可以说是区块链思想的先驱，对现代区块链技术的发明有着功不可没的启发作用。

由于知名Git托管网站Github的推动，Git已经占据现代开源社区中的绝大多数项目。与传统企业使用的版本管理系统SVN相比，Git由于其基于指针的文件系统结构，在部分操作上执行效率远胜于SVN（例如很大的项目在做分支切换时，Git利用指针切换可几乎瞬间完成，而SVN可能需要数秒到数十秒，具体我没有进行考证，有兴趣的可以自行尝试），并因此受到广泛好评。

## Git本地配置

你需要先安装Git命令行工具才能使用Git的功能。以下针对几个常见的操作系统平台进行介绍：

### Windows用户

1. 进入 [Git for Windows](https://github.com/git-for-windows/git/releases/latest) 下载页；
2. 在页面最底部点击下载`Git-2.xx.x.x-xx-bit.exe`并进行安装，安装时，在`Adjusting your PATH environment`选项中选择第三项`Use Git and optional Unix tools from the Windows Command Prompt`，即可将`git`、`ls`等命令安装到系统命令提示符中；
3. 安装好后，右击开始按钮，启动`命令提示符`，`cd`到需要操作的项目目录（需要提醒的是，Windows中，跨磁盘的`cd`需要加参数`/d`，例如若要从C分区切换到D分区，使用`cd /d D:`才能生效），即可使用`git`相关命令。

### macOS用户

1. 从`Mac App Store`安装`Xcode`（这一步一般也可以省略）；
2. 从`Dashboard`启动器打开`终端`，执行命令`xcode-select --install`，然后根据提示完成`Xcode command line tools`的下载和安装；
3. 然后在终端中`cd`到需要操作的项目目录，即可使用`git`相关命令。同样，macOS终端默认支持`cd`，`ls`等符合Unix规范的操作。

### Linux用户

1. 使用你的操作系统附带的包管理器（例如`apt-get`，`yum`，`dnf`，`pacman`等）安装`git`软件包。
2. 如果包管理器附带的`git`软件包太旧（早于1.7版本），请自行下载最新版本的`git`源码并编译安装。

### iOS手机端

你可以使用`Working Copy`应用（收费）在手机上进行Git项目管理和编辑。

## Git托管网站简介及在线配置

Git本身只是一个本地管理版本库的工具，与服务器同步只是它的附加功能，因此Git本身并不需要依赖服务器进行工作。但由于现代互联网的中心化现状，现代的多人协作大多需要依赖于一个统一、稳定的服务器作为代码库的中心，因此诸如Github之类的网站应运而生，我们称之为项目托管网站。

国际上常见的的Git项目托管网站有Github、Gitlab、BitBucket；国内常见的则有git@oschina（开源中国·码云）、coding等。另外，具有一定基础的运维人员也可以建立自己的Git托管服务器，以便管理企业内部的私密项目等。

本节我们以Github为例，介绍如何在项目托管网站上创建项目，并下载到本地或将本地已有项目上传。

### 在服务器端新建项目

首先我们要注册Github账号并登录，注册过程不详细赘述。登录后，通过右上角加号菜单打开`New Repository`开始新建一个项目。

![](https://ww4.sinaimg.cn/large/006tNbRwgy1feiy5bn6p5j31kw0wagtx.jpg)

1. `Owner`表示此项目的拥有者，如果你加入了某一团队组织，可以在这里选择将项目归组织所有；
2. `Repository Name`表示项目名称。建议仅使用大小写字母、数字、下划线作为项目名称；
3. `Description`可不填，表示该项目显示在Github上的一些说明文字；
4. `Public/Private`表示项目所属权限，Public表示所有人都能访问，Private表示仅自己和已授权的人可访问。Github鼓励开源，创建私有项目需要付费。若由于涉及组织隐私等问题，想要创建私有项目，可以使用Coding、git@oschina等国内网站进行托管；
5. `Initialize this repository with a README`会在服务器端自动创建一个`README.md`文件，在这里可以使用Markdown语言书写项目的一些介绍说明，它将被Markdown渲染器自动渲染并展示在项目主页上。**注意：新项目创建`README.md`文件会导致服务器端产生一个提交，若你是新手，并且需要上传本地已有项目，暂不建议使用；**
6. `Add .gitignore`会在服务器端自动创建一个`.gitignore`文件，使用该文件可以排除部分不需要进行管理的文件或文件夹，例如Windows端的`desktop.ini`、`Thumbs.db`，macOS端的`.DS_Store`，以及一些文本编辑器或IDE的本地配置文件等。**注意：新项目创建`.gitignore`文件会导致服务器端产生一个提交，若你是新手，并且需要上传本地已有项目，暂不建议使用；**
7. `Add a license`会在服务器端自动创建一个`LICENSE`文件，该文件用于给开源项目标注所使用的协议。你可以点击右面的问号了解各个协议的区别。**注意：新项目创建`LICENSE`文件会导致服务器端产生一个提交，若你是新手，并且需要上传本地已有项目，暂不建议使用；**
8. 最后，点击`Create Repository`确认新建这个项目。

新建项目之后，如果你没有选择添加任何文件，会出现如下的提示信息：

![](https://ww1.sinaimg.cn/large/006tNbRwgy1feiyqa4z4xj31kw0wa7e1.jpg)

如果你选择了添加文件，则会显示已经存在的文件列表。此时，你需要有一个本地的项目文件夹与它进行同步，方法主要有三种：

### 1：从服务器端下拉

此方法适合服务器端项目有数据、而本地没有要导入的数据的情况，或者服务端和本地都没有数据的情况。执行命令：

```
git clone https://github.com/用户名/项目名
```

其中`用户名`和`项目名`分别替换为你在Github的用户名和项目名；其中的`https`可以根据需求换成`http`或者`git`协议。另外由于Github的巧妙设置，此处的网址与项目主页的网址相同，可以直接将项目主页的地址拷贝过来_（但并不是所有托管网站都有这个特性，例如Coding就只能使用项目主页上提供的项目Clone地址，而不能使用项目主页的网址）_。

### 2：从本地上传

此方法适合本地有要导入的数据、而服务端没有数据的情况，或者服务端和本地都没有数据的情况。逐条执行命令：

```
cd 你的项目目录
git init
git add .
git commit -m "first commit"
git remote add origin https://github.com/用户名/项目名
git push -u origin master
```

后面将介绍这些命令，因此暂时不需要了解它们的含义。

### 3：两端合并

此方法适合本地有要导入的数据、而服务端也已经用`README.md`、`.gitignore`、`LICENSE`等文件对项目进行过初始化的情况。逐条执行命令：

```
cd 你的项目目录
git init
git add .
git commit -m "first commit"
git remote add origin https://github.com/用户名/项目名
git pull
git push -u origin master
```

如果本地和服务端有同名文件，最后的`push`会产生冲突，请暂时避免这种情况。

## Git基础命令详解

你（local）正和你的一个同事（another）一起进行开发，你们一开始都没有代码，只有服务器上有代码，服务器的代码更新到了`v1.1`版本，但你们俩就只能眼巴巴的看着服务器：
```
		v1.0  v1.1
remote  *----[*]>
```
这个图中，一条线代表一台机器上的项目库，每一个星号代表库上的一个版本，方括号代表当前项目所处的版本，箭头代表这条线延伸的方向。

现在你的同事找到了这样一条命令：

---
### git clone
格式：`git clone [服务器地址]`

该命令将从所给的地址中自动识别项目名称，用这个名称在当前目录下创建项目文件夹，并在创建好的项目文件夹中下载该项目，并对该服务器地址（别名自动设为`origin`）进行跟踪。这个命令是下载项目代码并开始开发的第一步。

---
于是你的同事使用`git clone https://github.com/用户名/项目名`拿到了项目，而且这个项目已经自动设置好跟服务器之间的跟踪关系了，你的同事很高兴。但是他没有告诉你这件事，你依然眼巴巴的看着服务器，然后你发现项目主页上有一个`Download Zip`的按钮，你点了一下，服务器上的项目就下载下来了，你把下载下来的压缩包解压，放在了一个文件夹里。但你发现各种`git`命令在这个文件夹里不起作用。这是因为下载的压缩包不带`.git`隐藏文件夹，它不会被`git`识别成项目目录。所以你找到了这样几条命令：

---
### git init
格式：`git init`

在当前目录生成`.git`隐藏文件夹，将当前目录初始化成一个项目目录。

### git remote add
格式：`git remote add [服务器别名] [服务器地址]`

在远程列表中添加一个服务器进行跟踪。解释：
1. 「远程」指托管网站或其他服务器上对应的项目，「跟踪」即与托管网站或其他服务器之间进行同步。
2. 一个本地项目可以跟踪多个远程项目，在`pull`或`push`时使用`-u [服务器别名]`参数可以切换到不同的远程项目；
3. 只有一个远程服务器时，一般使用`origin`作为别名。

### git remote remove
格式：`git remote remove [服务器别名]`

与`git remote add`对应，从远程列表中移除一个服务器。

### git remote set-url
格式：`git remote set-url [服务器别名] [服务器地址]`

更改远程列表中的某个别名对应的服务器地址。项目出现迁移、易主等变动之后，常常需要执行这个操作。

### git fetch
格式：`git fetch`

将远程服务器的`git`版本记录同步到本地，如果有新版本，将新版本的数据同步到本地，但暂时不改变本地的文件内容。

---
于是，你在你解压好的文件夹下使用`git init`、`git remote add origin https://github.com/用户名/项目名`、`git fetch`三个命令，成功让你的文件夹跟服务器同步了。

现在你和你的同事都拥有v1.1版本的代码，你们两人手中的项目都和服务器（remote）同步，像这样：
```
		v1.0  v1.1
another *----[*]>
remote  *----[*]>
local   *----[*]>
```
现在你在你的项目目录里新增一个文件`test.txt`，里面写上`Hello, World`，然后保存。下面我们通过几个命令让它同步到你同事的电脑上。

---
### git add
格式：`git add [文件]`

将指定的文件中所做的更改纳入暂存区，等待提交。解释：

1. Git有`暂存区`的概念，它是一个虚拟的区域，只有添加进来的文件才会被记录更改，没有添加进来的文件不会受到Git管理；
2. `暂存区`是一次性的，一旦进行提交（参见`git commit`），暂存区会清空，如果要继续记录某个文件的更改，需要重新进行`add`操作；
3. 使用此命令时，一般用`git add *`或`git add .`表示将当前目录下的所有文件和文件夹添加到暂存区。

顺便讲一下`git rm`：

### git rm
格式：`git rm [文件]`

与`git add`用法相似、意思相反，但不仅会将文件移出暂存区，**还会将指定的文件从磁盘上彻底删除，请慎用。**若不慎使用`git rm`删除了某个从未记录版本的文件，你也许可以使用[这里](http://www.spinics.net/lists/git/msg62499.html)提供的方法进行恢复。

---
现在我们回到`git add`命令。你使用`git add test.txt`或`git add *`将新增的文件增加到了暂存区（stage）：
```
		v1.0  v1.1
another *----[*]>
remote  *----[*]>
local   *----[*]>

+-- stage: ----------+
| [test.txt]         |
| +Hello, World      |
+--------------------+
```

---
### git commit
格式：`git commit -m "[版本说明]"`

将当前暂存区中的所有文件中的更改进行提交。解释：
1. 「提交」的意思是「在本地代码库上创建一个版本」，它是一个本地操作，而不是「发送到服务器」；
2. 必须指定版本说明；如果版本说明中不含空格或特殊字符，可以省略引号；
3. 如果没有添加`-m`参数及其后的版本说明，会打开一个`vim`编辑器允许你书写多行的版本说明，不过如果你还不会退出`vim`请不要轻易尝试。

---
现在，你使用`git commit -m "v1.2"`将暂存区里的文件提交到了本地代码库上：
```
		v1.0  v1.1
another *----[*]>
remote  *----[*]>   v1.2
local   *-----*----[*]>
					↑
+-- stage: --+      +-- new commit: -----+
| empty      |      | [test.txt]         |
|            |      | +Hello, World      |
+------------+      +--------------------+
```

---
### git push
格式：`git push`

该命令会将本地比远程服务器新增的所有版本推送到远程服务器上，让远程服务器的文件变成最新版本。注意，只有当本地比远程超前、远程比本地落后时才能执行`git push`，若本地与远程相互超前，请先用`git pull`将远程比本地超前的部分同步到本地。

---
现在，你使用`git push`将本地代码库新增的版本推送到服务器上：
```
		v1.0  v1.1
another *----[*]>   v1.2
remote  *-----*----[*]>
                    ↑ push
local   *-----*----[*]>
```

### git pull
格式：`git pull`

该命令会从远程服务器查询当前的项目有无新版本，如果有，会将新增加的所有版本情况获取回来，并且让你的项目库中的文件变成最新版本的。注意，只有当本地暂存区为空时才能执行`git pull`，否则请使用`git commit`创建新版本或用`git stash`备份暂存区。

---
现在，你通知你的同事有新版本了，他使用`git pull`将服务器上的新版本拉到他的电脑上：
```
		v1.0  v1.1  v1.2
another *-----*----[*]>
                    ↑ pull
remote  *-----*----[*]>
local   *-----*----[*]>
```

这样就完成了一次同步。下面我们将见证一次合并。现在你把`Hello, World`改成了`Hello, Git`，然后再次用`git add test.txt`或`git add *`将新的更改增加到了暂存区（stage）：
```
		v1.0  v1.1  v1.2
another *-----*----[*]>
remote  *-----*----[*]>
local   *-----*----[*]>

+-- stage: ----------+
| [test.txt]         |
| -Hello, World      |
| +Hello, Git        |
+--------------------+
```
然后，你使用`git commit -m "v1.3.a"`将暂存区里的文件提交到了本地代码库上：
```
		v1.0  v1.1  v1.2
another *-----*----[*]>
remote  *-----*----[*]>   v1.3.a
local   *-----*-----*----[*]>
					      ↑
+-- stage: --+            +-- new commit: -----+
| empty      |            | [test.txt]         |
|            |            | -Hello, World      |
+------------+            | +Hello, Git        |
                          +--------------------+
```
在你要同步之前，你的同事增加了一个新文件`test2.txt`，里面写上了`Hi, Github`，然后用同样的方法提交到了他自己的电脑上，这个版本叫`v1.3.b`：
```
                          +-- new commit: -----+
                          | [test2.txt]        |
                          | +Hi, Github        |
                          +--------------------+
                          ↓
		v1.0  v1.1  v1.2  v1.3.b
another *-----*-----*----[*]>
remote  *-----*----[*]>   v1.3.a
local   *-----*-----*----[*]>
					      ↑
                          +-- new commit: -----+
                          | [test.txt]         |
                          | -Hello, World      |
                          | +Hello, Git        |
                          +--------------------+
```
巧的是，他先把他的版本推送到了服务器：
```
		v1.0  v1.1  v1.2
another *-----*-----*----[*]> v1.3.b
remote  *-----*-----*----[*]> v1.3.b
local   *-----*-----*----[*]> v1.3.a
```
这时候，你想使用`git push`，却发现出错了，因为不光你比远程多了一个版本`v1.3.a`，远程也比你多了一个版本`v1.3.b`，按照`git push`的规定不能使用，需要先用`git pull`：
```
		v1.0  v1.1  v1.2
another *-----*-----*----[*]> v1.3.b
remote  *-----*-----*----[*]> v1.3.b

                          v1.3.b
                      ----*----
                     /         \
local   *-----*-----*-----*----[*]>
                          v1.3.a
```
这是什么图？可以发现，`git pull`首先在`local`的`v1.2`节点的后面添加了一个新的节点`v1.3.b`，与原来的`v1.3.a`并列，然后尝试将两个节点进行合并，得到了一个新的版本。其实，这个过程其实是先执行`git fetch`，然后执行`git merge`的过程，换句话说，`git pull`就是这两个命令的结合体。

而这个新的版本，名字叫`Merge branch 'master' of https://github.com/用户名/项目名`，是`git merge`自动生成的一个版本。如果两人的更改非常兼容（例如只修改了不同的文件，或者修改了相同文件的不同行），`git merge`就可以自动合并形成这个版本。

如果两个人凑巧修改了同一个文件的同一行，`git`将会停止自动合并，并出现`CONFLICT`开头的提示，有几个`CONFLICT`就代表有几个文件发生冲突。你需要到它所提示的文件中，找到这样的标记：
```
<<<<<<< HEAD
Hello, World
=======
Hello, Git
>>>>>>> theirs
```
其中HEAD（或其他别的名字）指你的更改，theirs（或其他别的名字）指对方的更改，你需要在七个等号前后两段中，保留一个合适的，或者手动合并两者的精华部分，然后去掉七个等号、七个大于号、七个小于号所在的行。最后，你需要`git add`、`git commit -m "解决冲突"`来手动解决冲突，生成一个手动合并后的版本，然后`git push`推送到服务器。

---
## 一些进阶操作

### git branch
格式：`git branch [-d] [分支名]`

新建一个分支；加`-d`表示删除一个分支。

刚才所提到的`git fetch`会容忍一个节点下面同时出现两个版本，但那只是临时的，在你下次使用`git push`之前，他们必须合并在一起才能继续工作。但有些情况下，我们需要在一个版本下发展出两个不同的版本，让他们分别进行开发，而且能让我们在适当的时机下将它们合并。`git`提供了这个功能：分支。你可以使用`git branch`增加新的分支，让他们与原来的分支互相独立发展，然后也可以在适当的时机用`git merge`合并它们。另外，一个项目本来就有一个默认分支，它叫`master`。

### git checkout
格式：`git checkout [指针名] [文件名]`

将当前工作区某个文件切换到某一个指针所指向的状态。如果不填文件名，则将整个工作区切换到该状态。

开头曾经介绍过Git是基于指针的文件系统，它有很多指针：
1. 每个版本的`commit`都有一个（几乎）唯一的SHA-1值，这个SHA-1值（也可以用前七位代替）就是这个`commit`的指针名；
2. 分支名也是一个指针，它指向这个分支上最新的提交；
3. `HEAD`也是一个指针，它指向当前所在分支上最新的提交；
4. `--`（两个减号）也是一个指针，它指向当前指向位置的父节点。

以上四种指针都可以用在`git checkout`中。

### git stash
格式：`git stash`

不提交当前暂存区的内容，而是将暂存区的内容暂时收到一个`stash`容器中，达到临时清空暂存区的效果，以方便进行`pull`操作。

### git stash pop
格式：`git stash pop`

将上次`git stash`收起来的东西恢复到暂存区上。

## 一些参考

学习Git的过程中，下列这些可以作为参考：
1. 查看Git当前状态的命令`git status`；
2. Git的帮助文档命令`git help [要查询的指令]`，执行后会打开man帮助程序，展示相关的帮助页（man的退出是q键）；
3. Git的日志命令`git log`，推荐使用`git log --graph --color`可以展示完整的版本关系图；
4. 撰写本文时，我并没有深刻研究Git原理，单凭一些项目经验进行了一些臆断，不免有错漏之处，只希望可以对新手学习Git有一些帮助。若要深入研究，请参考[廖雪峰Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)。