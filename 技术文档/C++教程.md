# C++教程

本教程仅针对大一C++基础做概括，以便读者快速学习和复习，希望达到举一反三的效果。

## 一、Hello World

```c++
#include <iostream>
using namespace std;

int main(int argc, char** argv) {
    cout << "Hello, World!" << endl;
	return 0;
}
```

一个标准的C++控制台程序要求函数名为`main`，参数可以是`int argc, char** argv`，也可以没有参数；返回值应该为`int`类型，并且要明确`return 0`，这两者是`gcc`编译器的要求，在Windows平台可不考虑，但为了代码规范还是希望尽量遵守。

## 二、变量和类型

### 1. 常量和变量

一个变量有类型、变量名、并在内存中占有一定的空间用于存储相应的数据。

常量是特殊的变量，常量可保护它自身所占的空间里的内容不变。

例：

```c++
// 定义int类型变量，值为整数2
int a = 2;
```

它所占的内存空间中的内容为：（假设为32位机器，即机器上int占32位空间）

```
00000000 00000000 00000000 00000010
```

**拓展**：可以看到，该变量在运行时只在内存中拥有数据空间，而不会记忆自己的名字和类型。如果需要深入理解计算机的运作方式，你需要知道，变量在运行时是没有名字和类型的，这些多余的信息会在编译期间被去除：

1. 代码里用变量名来区分变量，而编译之后的程序只需要用地址来区分变量。例如计算`int a = 3, b = 4, c = a + b;`时，编译器可能会把`3`和`4`分别释放到地址`10000000`和`10000001`上，然后计算`10000000`和`10000001`处数字的和，并放到地址`10000010`上；

2. 代码里用运算符表示一类运算，用类型来暗示具体进行何种运算，例如整数加法和浮点数加法都使用`+`运算符，但他们因为类型不同而规则不同；而编译器将会事先按照类型将运算转换为对应类型的机器指令，因此整数加法和浮点数加法将会转换成不同的机器指令。如果所有这种情况都这样处理，那么其实类型已经无关紧要了，因此可以暂且认为，编译器在编译时会丢弃基本数据的类型，不再对这些类型进行记忆（但实际上为了运行时做类型判断，类型依旧会被记忆，只是用途不再像代码里那么广泛）。例如上述`int a = 3, b = 4, c = a + b;`会被转换成以下几步：

   ````
   从 10000000 地址开始写 00000000 00000000 00000000 00000011
   从 10000001 地址开始写 00000000 00000000 00000000 00000100
   从 10000000 地址读取一个 32 位整数作为被加数
   从 10000001 地址读取一个 32 位整数作为加数
   等加法器完成计算
   将加法器得到的和转换成32位整数，从 10000010 地址开始写到内存上
   ````

理解这两点有助于理解静态语言的本质以及类型安全的本质。如果理解了可以尝试思考这个问题：能不能实现让用户输入一个变量名，然后不使用任何分支判断语句，直接返回这个变量名对应的变量的值？如果可以，怎么实现？如果不能，为什么？

### 2. 作用域

C++用大括号`{}`来表示作用域，外部的变量和函数可以被内部访问，内部的变量和函数不能被外部访问，并且通常会在当前作用域结束时销毁（静态变量除外）。例如：

```c++
cout << a; // 编译错误：未定义变量a
class A {
    cout << a; // 编译错误：未定义变量a
    int fun() {
        cout << a; // 运行时错误：变量a使用前未初始化 (*)
        for (int i = 0; i < 5; i++) {
            cout << a; // 运行时错误：变量a使用前未初始化 (*)
        }
      	int a; // 声明
      	cout << a; // 运行时错误：变量a使用前未初始化 (*)
        a = 10; // 初始化
        cout << a; // 输出10
        for (int i = 0; i < 5; i++) {
            cout << a; // 输出10 (**)
        }
      
        { // (***)
        	int a = 20;
            cout << a; // 输出20
        }
        cout << a; // 输出10
    }
    cout << a; // 编译错误：未定义变量a (****)
}
cout << a; // 编译错误：未定义变量a
```

上面的例子需要注意以下几点：

1. 注意编译错误和运行时错误的区别。编译错误是指编译期间，编译器可以检查到，并且会阻止继续编译的错误；运行时错误是指程序编译通过，但在运行时报错或异常退出。未定义变量在编译期间就可以检查到，是因为根据上一节**拓展**所说的，编译器需要把变量名转换成对应的地址，如果编译器找不到变量名对应的变量，那么就无法转换成正确的地址，于是不能继续编译。
2. 注意三个加`(*)`的错误，这三行语句虽然在`int a;`的声明之前，但需要注意的是，`int a`的作用域从`int fun() {`这里就开始了，因此虽然在`int a;`声明之前，却已经在作用域内的`a`是可以通过编译的，编译器可以在同一作用域内找到它的声明，但是运行时因为这里`a`还没有初始化，所以报错，一般提示为`Variable 'a' is used before it is initialized`（使用前未初始化）。
3. 需要提醒的是，某些编译器也可以提前发现上述问题，在编译期间报出错误，因此三个加`(*)`的错误也不一定就是运行时错误。
4. `(**)`处表明，在作用域外部声明的变量，在里面的作用域中通常可以访问到；
5. `(***)`处这个大括号是一种人工作用域，当你需要新开辟一个作用域，又没有`if`、`for`之类的语句要写，可以直接用一对大括号人工制造一个作用域。
6. 为什么需要新开辟作用域呢？因为同一作用域下不能声明重名变量。
7. 为什么需要声明重名变量呢？平时我们并不需要（也不提倡）声明重名变量，但这里是为了展示变量掩盖。变量掩盖（Shadowing）就是在`(***)`下面一行，当外面作用域已经有`a`，在内部作用域可以重新声明一个`a`，这时候内部作用域的`a`会掩盖外面的`a`，在作用域内部使用`a`将会优先使用内部作用域里面的变量`a`，而不再使用外面的同名变量。这个作用域结束之后再使用`a`还是会恢复使用外面的`a`，因为内部的`a`已经销毁了。
8. `(****)`处表明，内部作用域声明的变量，在外面不能被访问，这和第4点正好相反。

### 3. 关于类型

这里要深入理解第1节**拓展**所说的内容。

1. **类型是语言层面的，而不是机器层面的。**C++属于强类型静态语言，这种语言通常会定义一套类型，并要求开发者遵守，这是为了开发者更规范地编码、写出更可靠的程序，而非为计算机提供方便。因为变量的类型一旦经过编译就会被丢弃在一边，不再起决定性作用，而是换成严谨的机器指令（`把XXX地址当做32位整数取出来`；`把YYY当做单精度浮点数存到XXX里`；`把XXX和ZZZ两个地址里面的东西当做64位整数相加`）来决定到底要做什么，对于计算机来说，这种指令反而更准确易懂，而类型只是为了人类在编程过程中表达方便；
2. **类型隐含了存储空间的长度。**在学习指针时将会知道，指针所指的类型决定了指针移动的步长，因此类型隐含了所存内容的长度，这也表明，一个确定的类型，它的变量（对象）所占的长度也应该确定。理解了这个，你应该就能理解：_为什么类只能用定长数组、或用头指针指向动态开辟的数组，而不能用可变长度数组作为成员？_
3. **类型区分了变量可进行的运算。**例如只有基本类型可以做四则运算，结构体类型就不能，类类型则需要手动重载运算符才能实现四则运算。这些都是由类型和编译器来共同控制的。

### 4. 基本类型

基本类型都是基于数字的，他们一般都可以互相做四则运算、互相赋值（会自动转换）。

1. `int`：整数，最基本的类型。有长度和符号之分：

   (1) 长度有`short`、`long`、`long long`三种，若省略，默认为`short`短整数；

   (2) 符号有`signed`和`unsigned`两种，若省略，默认为`signed`有符号；

   (3) 若指定了长度或符号中的任意一个，可省略`int`，例如`long int`可直接写成`long`、`unsigned int`写成`unsigned`、`unsigned long int`写成`unsigned long`之类的类型；

   (4) 无符号整数可表示数的范围跟（相同长度的）有符号整数一样大，但是绝对值范围比有符号整数大一倍。例如32位机中`int`的范围是`-2147483648 ~ 2147483647`，而`unsigned`的范围是`0 ~ 4294967295`。

   (5) 注意溢出。例如32位机中`int`加法，`2147483647 + 1`会发生上溢，结果为`-2147483648`。

2. `float`、`double`：浮点数。`float`为单精度的，一般跟`int`所占内存长度一致；`double`则一般跟`long`所占内存长度一致。

3. `char`：ASCII字符，长度为`8 bit`即`1 Byte`，表示范围为`0 ~ 255`，但ASCII码表只使用其中`0 ~ 127`这128个位置用来表示字符。注意：

   (1) `char`类型也是一种超短的整数，可以直接跟整数做四则运算，只是它的前128个值被赋予了特殊含义，使得它在被输入、被输出时享受字符和ASCII码自动互相转换的特殊待遇，但`char`类型里面真的只存一个很短的整数，至于它能显示出各种不同的字符，完全是靠操作系统的功劳；

   (2) 需要记住的几个特殊ASCII值：`0 == '\0'`、`48 == '0'`、`65 == 'A'`、`97 == 'a'`。

4. `bool`：布尔值，用于表示逻辑命题的真假。

   (1) `bool`内部其实是占1个字节，8位的空间，只用最低位表示真假，其余位都是`0`。之所以能容忍这么浪费，是因为计算机存取内存本身就是按字节做单位的，存取一位和存取一个字节开销相当，如果用一位来存取，还要为了从字节里取出这一位而多做一次按位运算，反而不如直接存取字节划算；

   (2) 值得一提的是，`bool`是C++新增的类型，C语言中需要用`typedef int bool;` `#define true 1` `#define false 0`三句话来自定义一个布尔类型。因此C语言中**所有的条件判断、逻辑运算，都是看整数值是否非0，非0为真，0为假。C++为了兼容C的特性，也保留了这个特点，即使是`bool`类型，也是先自动转换成`int`再做判断的；**

   (3) 补充说明：`int`转换为`bool`时，非0为真，0为假；`bool`转换成`int`时，真变1，假变0。

数组

指针

引用

字符串

## 三、运算符和表达式

优先级和结合性

四则运算

下标运算

自增自减

类型转换

new和delete

sizeof

逻辑运算

地址运算

二进制运算

短路运算

三元运算

逗号运算符

运算符重载

## 四、流程控制

分支语句if

多分支语句switch

循环语句for、while、do...while

控制指令return、break、continue

## 五、函数

声明和实现

函数重载

默认参数

静态变量

传值与传引用

内联函数

函数指针

递归

## 六、宏

ifndef/define/endif

define

typedef

宏函数

## 七、异常处理

抛出异常

捕捉异常

捕捉列表

异常重抛

## 八、常见库函数的使用

cstdlib

ctime

cmath

cstring

iostream

iomanip

fstream

string

## 九、结构体和枚举

结构体

枚举

## 十、类和对象

声明和实现

构造与析构

继承

多态

初始化列表

访问控制

友元

静态成员

模板

## 附一、算法基础

复杂度与渐进分析

搜索算法

排序算法

## 附二、数据结构基础

连续线性表

链表

栈

队列

图和树

## 附三、计组相关

编码方式

编译期和运行期

类型的物理本质

堆空间、栈空间和内存管理