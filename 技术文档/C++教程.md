# C++教程

本教程仅针对大一C++基础做概括，以便读者快速学习和复习，希望达到举一反三的效果。

## 一、Hello World

```c++
#include <iostream>
using namespace std;

int main(int argc, char** argv) {
    cout << "Hello, World!" << endl;
	return 0;
}
```

一个标准的C++控制台程序要求函数名为`main`，参数可以是`int argc, char** argv`，也可以没有参数；返回值应该为`int`类型，并且要明确`return 0`，这两者是`gcc`编译器的要求，在Windows平台可不考虑，但为了代码规范还是希望尽量遵守。

## 二、变量和类型

### 1. 常量和变量

一个变量有类型、变量名、并在内存中占有一定的空间用于存储相应的数据。

常量是特殊的变量，常量可保护它自身所占的空间里的内容不变。

例：

```c++
// 定义int类型变量，值为整数2
int a = 2;
```

它所占的内存空间中的内容为：（假设为32位机器，即机器上int占32位空间）

```
00000000 00000000 00000000 00000010
```

**拓展**：可以看到，该变量在运行时只在内存中拥有数据空间，而不会记忆自己的名字和类型。如果需要深入理解计算机的运作方式，你需要知道，变量在运行时是没有名字和类型的，这些多余的信息会在编译期间被去除：

1. 代码里用变量名来区分变量，而编译之后的程序只需要用地址来区分变量。例如计算`int a = 3, b = 4, c = a + b;`时，编译器可能会把`3`和`4`分别释放到地址`10000000`和`10000001`上，然后计算`10000000`和`10000001`处数字的和，并放到地址`10000010`上；

2. 代码里用运算符表示一类运算，用类型来暗示具体进行何种运算，例如整数加法和浮点数加法都使用`+`运算符，但他们因为类型不同而规则不同；而编译器将会事先按照类型将运算转换为对应类型的机器指令，因此整数加法和浮点数加法将会转换成不同的机器指令。如果所有这种情况都这样处理，那么其实类型已经无关紧要了，因此可以暂且认为，编译器在编译时会丢弃基本数据的类型，不再对这些类型进行记忆（但实际上为了运行时做类型判断，类型依旧会被记忆，只是用途不再像代码里那么广泛）。例如上述`int a = 3, b = 4, c = a + b;`会被转换成以下几步：

   ````
   从 10000000 地址开始写 00000000 00000000 00000000 00000011
   从 10000001 地址开始写 00000000 00000000 00000000 00000100
   从 10000000 地址读取一个 32 位整数作为被加数
   从 10000001 地址读取一个 32 位整数作为加数
   等加法器完成计算
   将加法器得到的和转换成32位整数，从 10000010 地址开始写到内存上
   ````

理解这两点有助于理解静态语言的本质以及类型安全的本质。如果理解了可以尝试思考这个问题：能不能实现让用户输入一个变量名，然后不使用任何分支判断语句，直接返回这个变量名对应的变量的值？如果可以，怎么实现？如果不能，为什么？

### 2. 作用域

C++用大括号`{}`来表示作用域，外部的变量和函数可以被内部访问，内部的变量和函数不能被外部访问，并且通常会在当前作用域结束时销毁（静态变量除外）。例如：

```c++
cout << a; // 编译错误：未定义变量a
class A {
    cout << a; // 编译错误：未定义变量a
    int fun() {
        cout << a; // 运行时错误：变量a使用前未初始化 (*)
        for (int i = 0; i < 5; i++) {
            cout << a; // 运行时错误：变量a使用前未初始化 (*)
        }
      	int a; // 声明
      	cout << a; // 运行时错误：变量a使用前未初始化 (*)
        a = 10; // 初始化
        cout << a; // 输出10
        for (int i = 0; i < 5; i++) {
            cout << a; // 输出10 (**)
        }
      
        { // (***)
        	int a = 20;
            cout << a; // 输出20
        }
        cout << a; // 输出10
    }
    cout << a; // 编译错误：未定义变量a (****)
}
cout << a; // 编译错误：未定义变量a
```

上面的例子需要注意以下几点：

1. 注意编译错误和运行时错误的区别。编译错误是指编译期间，编译器可以检查到，并且会阻止继续编译的错误；运行时错误是指程序编译通过，但在运行时报错或异常退出。未定义变量在编译期间就可以检查到，是因为根据上一节**拓展**所说的，编译器需要把变量名转换成对应的地址，如果编译器找不到变量名对应的变量，那么就无法转换成正确的地址，于是不能继续编译。
2. 注意三个加`(*)`的错误，这三行语句虽然在`int a;`的声明之前，但需要注意的是，`int a`的作用域从`int fun() {`这里就开始了，因此虽然在`int a;`声明之前，却已经在作用域内的`a`是可以通过编译的，编译器可以在同一作用域内找到它的声明，但是运行时因为这里`a`还没有初始化，所以报错，一般提示为`Variable 'a' is being used before being initialized`（使用前未初始化）。
3. 需要提醒的是，某些编译器也可以提前发现上述问题，在编译期间报出错误，因此三个加`(*)`的错误也不一定就是运行时错误。
4. `(**)`处表明，在作用域外部声明的变量，在里面的作用域中通常可以访问到；
5. `(***)`处这个大括号是一种人工作用域，当你需要新开辟一个作用域，又没有`if`、`for`之类的语句要写，可以直接用一对大括号人工制造一个作用域。
6. 为什么需要新开辟作用域呢？因为同一作用域下不能声明重名变量。
7. 为什么需要声明重名变量呢？平时我们并不需要（也不提倡）声明重名变量，但这里是为了展示变量掩盖。变量掩盖（Shadowing）就是在`(***)`下面一行，当外面作用域已经有`a`，在内部作用域可以重新声明一个`a`，这时候内部作用域的`a`会掩盖外面的`a`，在作用域内部使用`a`将会优先使用内部作用域里面的变量`a`，而不再使用外面的同名变量。这个作用域结束之后再使用`a`还是会恢复使用外面的`a`，因为内部的`a`已经销毁了。
8. `(****)`处表明，内部作用域声明的变量，在外面不能被访问，这和第4点正好相反。

### 3. 关于类型

这里要深入理解第1节**拓展**所说的内容。

1. **类型是语言层面的，而不是机器层面的。**C++属于强类型静态语言，这种语言通常会定义一套类型，并要求开发者遵守，这是为了开发者更规范地编码、写出更可靠的程序，而非为计算机提供方便。因为变量的类型一旦经过编译就会被丢弃在一边，不再起决定性作用，而是换成严谨的机器指令（`把XXX地址当做32位整数取出来`；`把YYY当做单精度浮点数存到XXX里`；`把XXX和ZZZ两个地址里面的东西当做64位整数相加`）来决定到底要做什么，对于计算机来说，这种指令反而更准确易懂，而类型只是为了人类在编程过程中表达方便；
2. **类型隐含了存储空间的长度。**在学习指针时将会知道，指针所指的类型决定了指针移动的步长，因此类型隐含了所存内容的长度，这也表明，一个确定的类型，它的变量（对象）所占的长度也应该确定。理解了这个，你应该就能理解：_为什么类只能用定长数组、或用头指针指向动态开辟的数组，而不能用可变长度数组作为成员？_
3. **类型区分了变量可进行的运算。**例如只有基本类型可以做四则运算，结构体类型就不能，类类型则需要手动重载运算符才能实现四则运算。这些都是由类型和编译器来共同控制的。

### 4. 基本类型

基本类型都是基于数字的，他们一般都可以互相做四则运算、互相赋值（会自动转换）。

1. `int`：整数，最基本的类型。有长度和符号之分：

   (1) 长度有`short`、`long`、`long long`三种，若省略，默认为`short`短整数；

   (2) 符号有`signed`和`unsigned`两种，若省略，默认为`signed`有符号；

   (3) 若指定了长度或符号中的任意一个，可省略`int`，例如`long int`可直接写成`long`、`unsigned int`写成`unsigned`、`unsigned long int`写成`unsigned long`之类的类型；

   (4) 无符号整数可表示数的范围跟（相同长度的）有符号整数一样大，但是绝对值范围比有符号整数大一倍。例如32位机中`int`的范围是`-2147483648 ~ 2147483647`，而`unsigned`的范围是`0 ~ 4294967295`。

   (5) 注意溢出。例如32位机中`int`加法，`2147483647 + 1`会发生上溢，结果为`-2147483648`。

2. `float`、`double`：浮点数。`float`为单精度的，一般跟`int`所占内存长度一致；`double`则一般跟`long`所占内存长度一致。

3. `char`：ASCII字符，长度为`8 bit`即`1 Byte`，表示范围为`0 ~ 255`，但ASCII码表只使用其中`0 ~ 127`这128个位置用来表示字符。注意：

   (1) `char`类型也是一种超短的整数，可以直接跟整数做四则运算，只是它的前128个值被赋予了特殊含义，使得它在被输入、被输出时享受字符和ASCII码自动互相转换的特殊待遇，但`char`类型里面真的只存一个很短的整数，至于它能显示出各种不同的字符，完全是靠操作系统的功劳；

   (2) 需要记住的几个特殊ASCII值：`0 == '\0'`、`48 == '0'`、`65 == 'A'`、`97 == 'a'`。

4. `bool`：布尔值，用于表示逻辑命题的真假。

   (1) `bool`内部其实是占1个字节，8位的空间，只用最低位表示真假，其余位都是`0`。之所以能容忍这么浪费，是因为计算机存取内存本身就是按字节做单位的，存取一位和存取一个字节开销相当，如果用一位来存取，还要为了从字节里取出这一位而多做一次按位运算，反而不如直接存取字节划算；

   (2) 值得一提的是，`bool`是C++新增的类型，在C语言中，一般直接用一个`int`是否非0来表示真假，如果真的很想用`bool`类型，C语言需要用`typedef int bool;` `#define true 1` `#define false 0`三句话来自定义一个布尔类型。因此C语言中**所有的条件判断、逻辑运算，都是看整数值是否非0，非0为真，0为假。C++为了兼容C的特性，也保留了这个特点，即使是`bool`类型，也是先自动转换成`int`再做判断的；**

   (3) 补充说明：`int`转换为`bool`时，非0为真，0为假；`bool`转换成`int`时，真变1，假变0。

### 5. 数组

数组是一个固定长度的、多个相同类型变量的组合。

1. **数组的初始化**：数组和普通变量一样，定义后需要做初始化，否则其内部是之前废弃留下的内存内容。数组的初始化有如下几种方式：

   (1) **完整初始化**：既写明元素个数，又写明各个元素。例如`int a[5] = {1, 2, 3, 4, 5};`；

   (2) **省略长度初始化**：省略数组长度，写明各个元素。例如`int a[] = {1, 2, 3, 4, 5};`；

   (3) **省略0初始化**：对于整数，写明数组长度，可以省略一些元素，省略的元素将会放在数组末尾并初始化为0。例如`int a[5] = {1, 2, 3};`，后两个元素将会自动置0；甚至可以省略所有元素，让所有元素为0：`int a[5] = {};`。务必注意，这和`int a[5];`是完全不一样的，后者没有对数组进行初始化，而前者全部初始化为0；

   (4) **多维数组的一维初始化**：对于多维数组，可以用一维的初始化列表来初始化，而无需套上多层大括号。例如`int a[2][2] = {0, 1, 2, 3};`可以替代`int a[2][2] = {{0, 1}, {2, 3}};`

   (5) **字符串初始化**：对于长度足够的字符数组，可以用双引号括起的字符串字面量进行初始化，例如`char a[10] = "hello"`。这种情况下，数组前6位被设置为`'h', 'e', 'l', 'l', 'o', '\0'`，而后面的部分不会被赋值，因为只需要设置到`'\0'`为止就是一个合法字符串了。

   **注意**：数组只能在定义的同时进行初始化，一旦定义语句完成，数组是不能被赋值的，因为数组的本质是指针常量。

2. **数组的组成本质是内存上的一块连续线性空间。**例如在32位机中，`int a[10]`将会在内存中开辟`4 * 10 = 40`字节的空间，并将其首地址留在`a`中，此时`a`是一个类似于指针的存在。

3. **数组名就是指向数组首地址的指针常量。**C++的数组「记头不记尾」，所以为了让程序记住数组长度，一般情况下我们会选用以下几种方法之一来帮助我们记住数组长度：

   (1) **在需要的时候直接告诉程序数组长度。**例如`int a[10]`后，如果我们要用`for`循环遍历这个数组，程序因为记不住`a`的长度，不知道遍历到何时结束，在这个时候我们就可以通过「直接告诉它」来实现。像`for (int i = 0; i < 10; i++) {`这样，把这个长度`10`再告诉程序一遍，让他能正常完成当前的任务。这种方法适用于一些临时开辟、长度固定、或者不需要多次访问的数组。

   (2) **用一个`int`来保存数组长度。**例如`int a[10]`后，我们用`int length = 10`来保存这个数组的长度，以后需要遍历数组`a`的时候，用`length`的值来当做数组的长度。**需要注意的是，如果`a`的长度可能会改变，那么你需要始终维护这个`length`的值，保证它始终和数组长度相等，否则将会出现越界等不可预料的错误。拓展**：表示数组长度的`int`类型也可以称为`size_t`类型，`size_t`是一个类型宏，它跟`unsigned int`基本一致，但编译器会对它做一系列优化，所以碰到表示数组长度的变量，可以多用`size_t`类型来代替，这样写出来的程序更规范。

   (3) **用特殊值来表示数组结尾。**例如`int a[10]`后，假如我们用它来保存一系列自然数，那么我们就可以约定用不是自然数的`-1`来标记数组结尾。这样在`int a[10]`的空间里，我们可以放9个元素，后面跟一个`-1`来表示数组结束。

   事实上，用`int`保存数组长度、以及用特殊值表示数组结尾，这两种方法非常灵活，以至于我们不一定要把数组填满，也可以只利用数组的一部分，而且可以随时灵活改变里面元素的个数。为了方便理解，我们暂且把这种数组称为**稀疏数组**。稀疏数组一般有三种形式：

   (1) **变长稀疏数组**：**所有有效元素放在数组首端，用一个`int`来保存有效元素个数。**跟上面所说的类似，但这里保存的是**有效元素个数**，这个个数不一定等于数组长度，因为我们不一定把整个数组都填满，而是可以根据需要随时调整里面的元素个数。在稀疏数组的语境下，我们一般约定把有效元素放在数组首端，这样从数组头指针开始，按照有效元素个数做遍历，即可拿到所有的有效元素。**同样，这个`int`值需要在有效元素数量变化的时候手动改变，否则会出现越界等问题。**例：

   ```c++
   int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
   int length = 10;

   // 将会输出 0 1 2 3 4 5 6 7 8 9
   for (int i = 0; i < length; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要删去最后一个元素，只需要让length自减1即可，因为我们约定始终把length作为有效长度，超过的就视为无效
   length--;

   // 将会输出 0 1 2 3 4 5 6 7 8
   for (int i = 0; i < length; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要添加一个元素，只要把新元素放在a[length]处，然后length自加1即可
   a[length] = 18;
   length++;

   // 将会输出 0 1 2 3 4 5 6 7 8 18
   for (int i = 0; i < length; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 不过上述添加新元素的方法需要事先保证数组未满，如果数组已满：
   a[length] = 18; // length等于数组长度，发生越界，可能导致运行时报错、异常退出、或误修改其他变量
   length++;
   ```

   (2) **变界稀疏数组**：**所有有效元素放在数组首端，用特殊值来表示有效元素结尾。**字符串就是很典型的变界稀疏数组，它把人类能够读取的ASCII文字放在数组首端，并用特殊值0（'\0'）来表示字符串结尾，这样做的好处就是，可以在固定开辟一块足够长的空间的同时，对里面的内容长度没有太多限制，只要不超过`数组长度 - 1`即可。**同样，这个特殊值的位置需要在元素增加或者减少时进行移动，否则会出现越界等问题。**例：

   ```c++
   int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9， -1 };

   // 将会输出 0 1 2 3 4 5 6 7 8 9
   for (int i = 0; a[i] != -1; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要删去最后一个元素，需要先查找到最后一个元素在哪里
   int lastIndex = 0;
   while (a[lastIndex] != -1) {
       lastIndex++;
   }
   // 循环结束时，应有a[lastIndex] == -1，此时让它前一位也等于-1，即可达到删除一个元素的目的
   a[lastIndex - 1] = -1;

   // 将会输出 0 1 2 3 4 5 6 7 8
   for (int i = 0; a[i] != -1; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要添加一个元素，需要把新元素放在数组内首个-1的地方，然后把下一位改成-1
   int lastIndex = 0;
   while (a[lastIndex] != -1) {
       lastIndex++;
   }
   a[lastIndex] = 18;
   a[lastIndex + 1] = -1;

   // 将会输出 0 1 2 3 4 5 6 7 8 18
   for (int i = 0; a[i] != -1; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 不过上述添加新元素的方法需要事先保证数组未满，如果数组已满：
   int lastIndex = 0;
   while (a[lastIndex] != -1) {
       lastIndex++;
   }
   a[lastIndex] = 18;
   a[lastIndex + 1] = -1; // lastIndex + 1 等于数组长度，发生越界，可能导致运行时报错、异常退出、或误修改其他变量
   ```

   (3) **无效化稀疏数组**：偶尔用到。**用一个固定不变的`int`表示数组长度，数组中有一个特殊值表示无效元素，所有不等于该值的元素，无论在特殊值的左边还是右边，都视为有效元素。**这种用法适合需要经常删除某些位于数组中间的元素的情况。遍历无效化稀疏数组时，需要从头遍历到尾，并且排除那些等于特殊值的元素。例如：

   ```c++
   int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
   const int length = 10;

   // 将会输出 0 1 2 3 4 5 6 7 8 9
   for (int i = 0; i < length; i++) {
     	if (a[i] != -1) {
       	cout << i << " ";
       }
   }
   cout << endl;

   // 要找到并且删去等于5的元素，只需要找到后把它设置为-1
   for (int i = 0; i < length; i++) {
     	if (a[i] == 5) {
       	a[i] = -1;
       }
   }

   // 将会输出 0 1 2 3 4 6 7 8 9
   for (int i = 0; i < length; i++) {
     	if (a[i] != -1) {
       	cout << i << " ";
       }
   }
   cout << endl;

   // 要添加新元素18，只需要找到第一个-1后把它设置为18，然后退出循环，防止给多个-1赋值
   for (int i = 0; i < length; i++) {
     	if (a[i] == -1) {
       	a[i] = 18;
         	break;
       }
   }

   // 将会输出 0 1 2 3 4 18 6 7 8 9
   for (int i = 0; i < length; i++) {
     	if (a[i] != -1) {
       	cout << i << " ";
       }
   }
   cout << endl;

   // 不过上述添加新元素的方法需要事先保证数组未满
   // 如果数组已满，所有元素都不为-1，if中的语句将不会被执行，18将不会添加到数组中
   // 我们可以结合for循环的跳出判断，及时发现这种情况
   // 这里我们使用计数器跳出判断法，后面for循环部分会讲到
   int i;
   for (i = 0; i < length; i++) {
     	if (a[i] == -1) {
       	a[i] = 18;
         	break;
       }
   }
   if (i == length) {
       cout << "数组已满，添加元素失败" << endl;
   }
   ```

   稀疏数组都是开发者自己与自己的约定，是数组的一些特殊用法，并不是C++提供的功能，学习时需要掌握其原理，知道为什么这样做。

4. **二维数组和多维数组**：以二维数组为例。二维数组就是数组的数组，也就是以数组为元素的数组。理解二维数组，需要从数组的数组性和指针性两方面来理解。

   (1) **二维数组的元素是一维数组，这些一维数组紧挨着存放在内存中。**因此，相邻两个一维数组是相连的，如果拥有第一个一维数组的尾元素指针，将其+1，即可得到第二个一维数组的首元素指针，这可以称为**二维数组的指针穿透**；如果拥有第一个一维数组的尾元素下标，将其+1，对第一个一维数组取这个下标内的元素，结果将是第二个一维数组的首元素，这可以称为**二维数组的下标穿透**。指针穿透和下标穿透不算越界，因为二维数组是一次性申请的一大块空间，在这一大块空间内，所有元素都是「一家人」，不存在跨界访问的限制。

   关于指针穿透和下标穿透，举一个例子：

   ```c++
   int a[3][4] = {
     1,  2,  3,  4, 
     5,  6,  7,  8, 
     9, 10, 11, 12
   }; // 每四个元素为一个一维数组，共三个一维数组

   // 下面用三种方法访问值为7的元素
   cout << a[1][2] << endl; // 输出7

   cout << a[0][1 * 4 + 2] << endl; // 输出7，下标穿透

   cout << *(*a + 1 * 4 + 2) << endl; // 输出7，指针穿透
   ```

   事实上，上述下标穿透和指针穿透的例子可以利用**下标运算恒等式**相互转换，后面会讲到。

   (2) **二维数组是指向第一个一维数组的指针，而第一个一维数组本身又是指向其第一个元素的指针**，因此二维数组是间接指向其第一个「元素的元素」的「指针的指针」。

   (3) **动态二维数组的特殊性**：如果`new`一个指针数组，然后对其中每个指针赋予一个`new`出来的一维数组，那么将会得到一个**动态二维数组**。**动态二维数组不是二维数组**，它只是普通的指针数组，虽然一般用法跟二维数组相似，但不满足二维数组的连续性，即**动态二维数组的相邻两个一维数组之间不一定相连**，因为它们不是一次性开出的大块空间，而是通过多次`new`运算开出来的多块空间。因此，**动态二维数组不具有指针穿透和下标穿透特性**，只能老老实实用两次下标运算访问其一维数组的元素。

5. **数组深拷贝和浅拷贝**：

   (1) 因为数组的本质是头指针常量，**数组不允许直接被赋值**。但数组作为指针，可以赋给其它指针，这称为**浅拷贝**；也可以把元素一个一个赋值给其它数组的元素，这称为**深拷贝**。

   (2) **浅拷贝**只是把自己的头指针共享了一份，让另一个指针也指向自己的存储区域。因此，浅拷贝后，两个指针将指向同一个数组空间，通过这两个指针对数组做修改是完全同步的，即一个指针修改了数组，也会影响另一个指针看到的数组内容，因此浅拷贝的两个指针**严格意义上不能看作两个数组**。

   (3) **深拷贝**是将自己的数组内容全部复制给另一个数组，让另一个数组里的内容和自己的数组一致，得到的两个数组内容一样，但互相独立，不再有关联，是**严格意义上的两个数组**。

### 6. 指针

指针是表示内存地址的一个数值，利用指针运算，我们可以在内存中跟踪某个特定位置的变量、在变量附近的内存空间内访问其它变量等等。

1. **指针的获得**：我们可以通过取地址运算`&`、数组名、字符串名、系统提供的句柄等途径来获得一个指针。例如：

   ```c++
   int a1 = 10;
   int* p1 = &a1; // 取地址运算，取a的地址赋给指针p

   int a2[10] = {}; // 数组的本质是指针常量，常量可以赋给变量
   int* p2 = a2; 

   char a3[10] = "hello"; // 字符串的本质是字符数组，也就是字符指针常量，同样可以赋给指针变量
   char* p3 = a3;
   ```

2. **常量指针**：常量指针是指向常量的指针，一般用于**把读取一块内存区域内容的权限转交给另一段程序，但又不想让这段程序修改该区域内容**的情况。常量指针的类型说明符是`const sometype *`或者`sometype const *`，其中`sometype`表示要指向的类型。

   (1) **常量指针是指向常量的指针，但不一定非要把一个常量的地址赋给它，也可以把变量的地址赋给它。**一种便于理解的解释是，系统会自动把变量的指针隐式转换为常量的指针，而不能把常量的指针隐式转换为变量的指针。这听起来似乎和「常量可以赋给变量，变量不能赋给常量」相反，但**常量指针**是**指向常量的指针**，**常量指针不是常量**，所以根本就不应该适用这句话。**更深层次的解释**需要结合类型的本质来看，所谓常量指针，变量指针，都只是C++层面的类型，而真正运行起来的时候，计算机里面存储的都只是一个整数地址，我们在C++层面所做的类型转换，从计算机层面来看都是徒劳无功，没有意义的。但这个「把变量指针转换成常量指针」的类型转换的意义恰恰停留在C++编译器层面上，因为常量指针解引用之后会成为常量类型，编译器不允许代码对常量类型做更改操作，所以正好满足了我们「既要把指针传给别人，又不想让他动里面的东西」的需求。

   (2) **常量指针广泛用于类库中，作为常数组、常字符串的载体存在着。**在C++标准库中，常量指针大量存在，一般规则是：**如果一个函数接受某个指针参数，且不需要改变指针指向的内容，那么这个参数就能写成常量指针；如果一个参数能写成常量指针，那么它一定要写成常量指针，否则会影响函数的使用。**为什么会影响函数的使用呢？原因还是在于上一点所说的「常量指针不能赋给变量指针」。如果你的程序拿到了一个常量指针，你需要把它传给函数进行使用，但函数接受的是变量指针，那就无法赋值，出现编译错误。初学者暂且可以忽略这个问题，但若要深入使用C++进行开发，务必注意把函数中能定义成常量指针的都写成常量指针。

3. **指针常量**：指针常量又称为常指针，它**是一个指针**，同时也**是一个常量**，即指针常量所指的地址不能被改变，而指向的区域内容可以改变，不受影响。这跟常量指针正好相反。指针常量的类型说明符是`sometype * const`。指针常量满足「常量可以赋给变量，变量不能赋给常量」的正常规则，但指针常量其实很少被用到，用处不大。

4. **指针的移动**：指针作为一个地址，可以进行一定的运算，即指针的移动。这里首先要介绍`sizeof`运算。`sizeof`是求某个类型或某个变量所占存储空间的运算符，它计算的结果是以存储字长为单位的。对于普通计算机，存储字长都是1字节，因此`sizeof char`的结果一定为1；同理，32位机上`sizeof int`的结果是4。恰巧计算机的地址也是以存储字长为单位的，在内存中移动1字节，地址就加1或减1。因此如果我们有一个`int`数组，知道了第一个元素的地址（这里假设不适用指针，用整数类型表示地址），那么对它`+4`就得到第二个元素的地址。这里我们就要注意到相邻的`int`和`int`之间，地址相差4个存储字长。但C++的指针会自动帮我们计算这个类型的长度，原来需要`+4`的，使用指针类型只需要`+1`即可。据此我们可以归纳为：**一般地，对于`sometype *`类型的指针`p`，`p + 1`就是指向相邻的下一个`sometype`类型变量的指针；对应地，`(int)(p + 1) - (int)p`的值一定等于`sizeof sometype`的值。**另外需要注意的是，指针`p`本身没有移动，而是加法的结果`p + 1`指向了下一个元素。如果要指针本身进行移动，可以用`++`、`--`、`+=`、`-=`、或者普通的赋值运算`p = p + 1`等，前提是`p`本身**不是指针常量**。

引用

字符串

## 三、运算符和表达式

优先级和结合性

四则运算

下标运算

自增自减

类型转换

new和delete

sizeof

逻辑运算

地址运算

二进制运算

短路运算

三元运算

逗号运算符

运算符重载

## 四、流程控制

分支语句if

多分支语句switch

循环语句for、while、do...while

控制指令return、break、continue

## 五、函数

声明和实现

函数重载

默认参数

静态变量

传值与传引用

内联函数

函数指针

递归

## 六、宏

ifndef/define/endif

define

typedef

宏函数

## 七、异常处理

抛出异常

捕捉异常

捕捉列表

异常重抛

## 八、常见库函数的使用

cstdlib

ctime

cmath

cstring

iostream

iomanip

fstream

string

## 九、结构体和枚举

结构体

枚举

## 十、类和对象

声明和实现

构造与析构

继承

多态

初始化列表

访问控制

友元

静态成员

模板

## 附一、算法基础

复杂度与渐进分析

搜索算法

排序算法

## 附二、数据结构基础

连续线性表

链表

栈

队列

图和树

## 附三、计组相关

编码方式

编译期和运行期

类型的物理本质

堆空间、栈空间和内存管理