# C++教程

本教程仅针对大一C++基础做概括，以便读者快速学习和复习，希望达到举一反三的效果。

## 一、Hello World

```c++
#include <iostream>
using namespace std;

int main(int argc, char** argv) {
    cout << "Hello, World!" << endl;
    return 0;
}
```

一个标准的C++控制台程序要求函数名为`main`，参数可以是`int argc, char** argv`，也可以没有参数；返回值应该为`int`类型，并且要明确`return 0`，这两者是`gcc`编译器的要求，在Windows平台可不考虑，但为了代码规范还是希望尽量遵守。

## 二、变量和类型

### 1. 常量和变量

一个变量有类型、变量名、并在内存中占有一定的空间用于存储相应的数据。

常量是特殊的变量，常量可保护它自身所占的空间里的内容不变。

例：

```c++
// 定义int类型变量，值为整数2
int a = 2;
```

它所占的内存空间中的内容为：（假设为32位机器，即机器上int占32位空间）

```
00000000 00000000 00000000 00000010
```

**拓展**：可以看到，该变量在运行时只在内存中拥有数据空间，而不会记忆自己的名字和类型。如果需要深入理解计算机的运作方式，你需要知道，变量在运行时是没有名字和类型的，这些多余的信息会在编译期间被去除：

1. 代码里用变量名来区分变量，而编译之后的程序只需要用地址来区分变量。例如计算`int a = 3, b = 4, c = a + b;`时，编译器可能会把`3`和`4`分别释放到地址`10000000`和`10000001`上，然后计算`10000000`和`10000001`处数字的和，并放到地址`10000010`上；

2. 代码里用运算符表示一类运算，用类型来暗示具体进行何种运算，例如整数加法和浮点数加法都使用`+`运算符，但他们因为类型不同而规则不同；而编译器将会事先按照类型将运算转换为对应类型的机器指令，因此整数加法和浮点数加法将会转换成不同的机器指令。如果所有这种情况都这样处理，那么其实类型已经无关紧要了，因此可以暂且认为，编译器在编译时会丢弃基本数据的类型，不再对这些类型进行记忆（但实际上为了运行时做类型判断，类型依旧会被记忆，只是用途不再像代码里那么广泛）。例如上述`int a = 3, b = 4, c = a + b;`会被转换成以下几步：

   ````
   从 10000000 地址开始写 00000000 00000000 00000000 00000011
   从 10000001 地址开始写 00000000 00000000 00000000 00000100
   从 10000000 地址读取一个 32 位整数作为被加数
   从 10000001 地址读取一个 32 位整数作为加数
   等加法器完成计算
   将加法器得到的和转换成32位整数，从 10000010 地址开始写到内存上
   ````

理解这两点有助于理解静态语言的本质以及类型安全的本质。如果理解了可以尝试思考这个问题：能不能实现让用户输入一个变量名，然后不使用任何分支判断语句，直接返回这个变量名对应的变量的值？如果可以，怎么实现？如果不能，为什么？

### 2. 作用域

C++用大括号`{}`来表示作用域，外部的变量和函数可以被内部访问，内部的变量和函数不能被外部访问，并且通常会在当前作用域结束时销毁（静态变量除外）。例如：

```c++
cout << a; // 编译错误：未定义变量a
class A {
    cout << a; // 编译错误：未定义变量a
    int fun() {
        cout << a; // 运行时错误：变量a使用前未初始化 (*)
        for (int i = 0; i < 5; i++) {
            cout << a; // 运行时错误：变量a使用前未初始化 (*)
        }
        int a; // 声明
        cout << a; // 运行时错误：变量a使用前未初始化 (*)
        a = 10; // 初始化
        cout << a; // 输出10
        for (int i = 0; i < 5; i++) {
            cout << a; // 输出10 (**)
        }
      
        { // (***)
            int a = 20;
            cout << a; // 输出20
        }
        cout << a; // 输出10
    }
    cout << a; // 编译错误：未定义变量a (****)
};
cout << a; // 编译错误：未定义变量a
```

上面的例子需要注意以下几点：

1. 注意编译错误和运行时错误的区别。编译错误是指编译期间，编译器可以检查到，并且会阻止继续编译的错误；运行时错误是指程序编译通过，但在运行时报错或异常退出。未定义变量在编译期间就可以检查到，是因为根据上一节**拓展**所说的，编译器需要把变量名转换成对应的地址，如果编译器找不到变量名对应的变量，那么就无法转换成正确的地址，于是不能继续编译。
2. 注意三个加`(*)`的错误，这三行语句虽然在`int a;`的声明之前，但需要注意的是，`int a`的作用域从`int fun() {`这里就开始了，因此虽然在`int a;`声明之前，却已经在作用域内的`a`是可以通过编译的，编译器可以在同一作用域内找到它的声明，但是运行时因为这里`a`还没有初始化，所以报错，一般提示为`Variable 'a' is being used before being initialized`（使用前未初始化）。
3. 需要提醒的是，某些编译器也可以提前发现上述问题，在编译期间报出错误，因此三个加`(*)`的错误也不一定就是运行时错误。
4. `(**)`处表明，在作用域外部声明的变量，在里面的作用域中通常可以访问到；
5. `(***)`处这个大括号是一种人工作用域，当你需要新开辟一个作用域，又没有`if`、`for`之类的语句要写，可以直接用一对大括号人工制造一个作用域。
6. 为什么需要新开辟作用域呢？因为同一作用域下不能声明重名变量。
7. 为什么需要声明重名变量呢？平时我们并不需要（也不提倡）声明重名变量，但这里是为了展示变量掩盖。变量掩盖（Shadowing）就是在`(***)`下面一行，当外面作用域已经有`a`，在内部作用域可以重新声明一个`a`，这时候内部作用域的`a`会掩盖外面的`a`，在作用域内部使用`a`将会优先使用内部作用域里面的变量`a`，而不再使用外面的同名变量。这个作用域结束之后再使用`a`还是会恢复使用外面的`a`，因为内部的`a`已经销毁了。
8. `(****)`处表明，内部作用域声明的变量，在外面不能被访问，这和第4点正好相反。

### 3. 关于类型

这里要深入理解第1节**拓展**所说的内容。

1. **类型是语言层面的，而不是机器层面的。**C++属于强类型静态语言，这种语言通常会定义一套类型，并要求开发者遵守，这是为了开发者更规范地编码、写出更可靠的程序，而非为计算机提供方便。因为变量的类型一旦经过编译就会被丢弃在一边，不再起决定性作用，而是换成严谨的机器指令（`把XXX地址当做32位整数取出来`；`把YYY当做单精度浮点数存到XXX里`；`把XXX和ZZZ两个地址里面的东西当做64位整数相加`）来决定到底要做什么，对于计算机来说，这种指令反而更准确易懂，而类型只是为了人类在编程过程中表达方便；
2. **类型隐含了存储空间的长度。**在学习指针时将会知道，指针所指的类型决定了指针移动的步长，因此类型隐含了所存内容的长度，这也表明，一个确定的类型，它的变量（对象）所占的长度也应该确定。理解了这个，你应该就能理解：_为什么类只能用定长数组、或用头指针指向动态开辟的数组，而不能用可变长度数组作为成员？_
3. **类型区分了变量可进行的运算。**例如只有基本类型可以做四则运算，结构体类型就不能，类类型则需要手动重载运算符才能实现四则运算。这些都是由类型和编译器来共同控制的。

### 4. 基本类型

基本类型都是基于数字的，他们一般都可以互相做四则运算、互相赋值（会自动转换）。

1. `int`：整数，最基本的类型。有长度和符号之分：

   (1) 长度有`short`、`long`、`long long`三种，若省略，默认为`short`短整数；

   (2) 符号有`signed`和`unsigned`两种，若省略，默认为`signed`有符号；

   (3) 若指定了长度或符号中的任意一个，可省略`int`，例如`long int`可直接写成`long`、`unsigned int`写成`unsigned`、`unsigned long int`写成`unsigned long`之类的类型；

   (4) 无符号整数可表示数的范围跟（相同长度的）有符号整数一样大，但是绝对值范围比有符号整数大一倍。例如32位机中`int`的范围是`-2147483648 ~ 2147483647`，而`unsigned`的范围是`0 ~ 4294967295`。

   (5) 注意溢出。例如32位机中`int`加法，`2147483647 + 1`会发生上溢，结果为`-2147483648`。

   (6) 整数字面量：`L`结尾表示长整数`long`类型，例如`long a = 123456789012345L`；`0x`开头表示十六进制，例如`int a = 0x1F`，则`a`的十进制值为`31`。`0`开头表示八进制，例如`int a = 012`，则`a`的十进制值为`10`。

2. `float`、`double`：浮点数。`float`为单精度的，一般跟`int`所占内存长度一致；`double`则一般跟`long`所占内存长度一致。浮点数字面量中，`f`结尾表示`float`类型，不加`f`默认为`double`类型。

3. `char`：ASCII字符，长度为`8 bit`即`1 Byte`，表示范围为`0 ~ 255`，但ASCII码表只使用其中`0 ~ 127`这128个位置用来表示字符。

   (1) `char`类型也是一种超短的整数，可以直接跟整数做四则运算，只是它的前128个值被赋予了特殊含义，使得它在被输入、被输出时享受字符和ASCII码自动互相转换的特殊待遇，但`char`类型里面真的只存一个很短的整数，至于它能显示出各种不同的字符，完全是靠操作系统的功劳；

   (2) 需要记住的几个特殊ASCII值：`0 == '\0'`、`48 == '0'`、`65 == 'A'`、`97 == 'a'`。

   (3) **字符字面量的转义**：用`''`包含起来的字符称为字符字面量。字符字面量中，一些特殊字符由于不能直接出现在代码中，需要用多个字符代替，常见的有`\n`表示回车，`\t`表示制表符Tab，两个反斜杠`\\`表示一个反斜杠`\`，`\'`表示单引号`'`等。

4. `bool`：布尔值，用于表示逻辑命题的真假。

   (1) `bool`内部其实是占1个字节，8位的空间，只用最低位表示真假，其余位都是`0`。之所以能容忍这么浪费，是因为计算机存取内存本身就是按字节做单位的，存取一位和存取一个字节开销相当，如果用一位来存取，还要为了从字节里取出这一位而多做一次按位运算，反而不如直接存取字节划算；

   (2) 值得一提的是，`bool`是C++新增的类型，在C语言中，一般直接用一个`int`是否非0来表示真假，如果真的很想用`bool`类型，C语言需要用`typedef int bool;` `#define true 1` `#define false 0`三句话来自定义一个布尔类型。因此C语言中**所有的条件判断、逻辑运算，都是看整数值是否非0，非0为真，0为假。C++为了兼容C的特性，也保留了这个特点，即使是`bool`类型，也是先自动转换成`int`再做判断的；**

   (3) 补充说明：`int`转换为`bool`时，非0为真，0为假；`bool`转换成`int`时，真变1，假变0。

### 5. 数组

数组是一个固定长度的、多个相同类型变量的组合。

1. **数组的初始化**：数组和普通变量一样，定义后需要做初始化，否则其内部是之前废弃留下的内存内容。数组的初始化有如下几种方式：

   (1) **完整初始化**：既写明元素个数，又写明各个元素。例如`int a[5] = {1, 2, 3, 4, 5};`；

   (2) **省略长度初始化**：省略数组长度，写明各个元素。例如`int a[] = {1, 2, 3, 4, 5};`；

   (3) **省略0初始化**：对于整数，写明数组长度，可以省略一些元素，省略的元素将会放在数组末尾并初始化为0。例如`int a[5] = {1, 2, 3};`，后两个元素将会自动置0；甚至可以省略所有元素，让所有元素为0：`int a[5] = {};`。务必注意，这和`int a[5];`是完全不一样的，后者没有对数组进行初始化，而前者全部初始化为0；

   (4) **多维数组的一维初始化**：对于多维数组，可以用一维的初始化列表来初始化，而无需套上多层大括号。例如`int a[2][2] = {0, 1, 2, 3};`可以替代`int a[2][2] = {{0, 1}, {2, 3}};`

   (5) **字符串初始化**：对于长度足够的字符数组，可以用双引号括起的字符串字面量进行初始化，例如`char a[10] = "hello"`。这种情况下，数组前6位被设置为`'h', 'e', 'l', 'l', 'o', '\0'`，而后面的部分不会被赋值，因为只需要设置到`'\0'`为止就是一个合法字符串了。

   **注意**：数组只能在定义的同时进行初始化，一旦定义语句完成，数组是不能被赋值的，因为数组的本质是指针常量。

2. **数组的组成本质是内存上的一块连续线性空间。**例如在32位机中，`int a[10]`将会在内存中开辟`4 * 10 = 40`字节的空间，并将其首地址留在`a`中，此时`a`是一个类似于指针的存在。

3. **数组名就是指向数组首地址的指针常量。**C++的数组「记头不记尾」，所以为了让程序记住数组长度，一般情况下我们会选用以下几种方法之一来帮助我们记住数组长度：

   (1) **在需要的时候直接告诉程序数组长度。**例如`int a[10]`后，如果我们要用`for`循环遍历这个数组，程序因为记不住`a`的长度，不知道遍历到何时结束，在这个时候我们就可以通过「直接告诉它」来实现。像`for (int i = 0; i < 10; i++) {`这样，把这个长度`10`再告诉程序一遍，让他能正常完成当前的任务。这种方法适用于一些临时开辟、长度固定、或者不需要多次访问的数组。

   (2) **用一个`int`来保存数组长度。**例如`int a[10]`后，我们用`int length = 10`来保存这个数组的长度，以后需要遍历数组`a`的时候，用`length`的值来当做数组的长度。**需要注意的是，如果`a`的长度可能会改变，那么你需要始终维护这个`length`的值，保证它始终和数组长度相等，否则将会出现越界等不可预料的错误。拓展**：表示数组长度的`int`类型也可以称为`size_t`类型，`size_t`是一个类型宏，它跟`unsigned int`基本一致，但编译器会对它做一系列优化，所以碰到表示数组长度的变量，可以多用`size_t`类型来代替，这样写出来的程序更规范。

   (3) **用特殊值来表示数组结尾。**例如`int a[10]`后，假如我们用它来保存一系列自然数，那么我们就可以约定用不是自然数的`-1`来标记数组结尾。这样在`int a[10]`的空间里，我们可以放9个元素，后面跟一个`-1`来表示数组结束。

   事实上，用`int`保存数组长度、以及用特殊值表示数组结尾，这两种方法非常灵活，以至于我们不一定要把数组填满，也可以只利用数组的一部分，而且可以随时灵活改变里面元素的个数。为了方便理解，我们暂且把这种数组称为**稀疏数组**。稀疏数组一般有三种形式：

   (1) **变长稀疏数组**：**所有有效元素放在数组首端，用一个`int`来保存有效元素个数。**跟上面所说的类似，但这里保存的是**有效元素个数**，这个个数不一定等于数组长度，因为我们不一定把整个数组都填满，而是可以根据需要随时调整里面的元素个数。在稀疏数组的语境下，我们一般约定把有效元素放在数组首端，这样从数组头指针开始，按照有效元素个数做遍历，即可拿到所有的有效元素。**同样，这个`int`值需要在有效元素数量变化的时候手动改变，否则会出现越界等问题。**例：

   ```c++
   int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
   int length = 10;

   // 将会输出 0 1 2 3 4 5 6 7 8 9
   for (int i = 0; i < length; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要删去最后一个元素，只需要让length自减1即可，因为我们约定始终把length作为有效长度，超过的就视为无效
   length--;

   // 将会输出 0 1 2 3 4 5 6 7 8
   for (int i = 0; i < length; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要添加一个元素，只要把新元素放在a[length]处，然后length自加1即可
   a[length] = 18;
   length++;

   // 将会输出 0 1 2 3 4 5 6 7 8 18
   for (int i = 0; i < length; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 不过上述添加新元素的方法需要事先保证数组未满，如果数组已满：
   a[length] = 18; // length等于数组长度，发生越界，可能导致运行时报错、异常退出、或误修改其他变量
   length++;
   ```

   (2) **变界稀疏数组**：**所有有效元素放在数组首端，用特殊值来表示有效元素结尾。**字符串就是很典型的变界稀疏数组，它把人类能够读取的ASCII文字放在数组首端，并用特殊值0（'\0'）来表示字符串结尾，这样做的好处就是，可以在固定开辟一块足够长的空间的同时，对里面的内容长度没有太多限制，只要不超过`数组长度 - 1`即可。**同样，这个特殊值的位置需要在元素增加或者减少时进行移动，否则会出现越界等问题。**例：

   ```c++
   int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9， -1 };

   // 将会输出 0 1 2 3 4 5 6 7 8 9
   for (int i = 0; a[i] != -1; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要删去最后一个元素，需要先查找到最后一个元素在哪里
   int lastIndex = 0;
   while (a[lastIndex] != -1) {
       lastIndex++;
   }
   // 循环结束时，应有a[lastIndex] == -1，此时让它前一位也等于-1，即可达到删除一个元素的目的
   a[lastIndex - 1] = -1;

   // 将会输出 0 1 2 3 4 5 6 7 8
   for (int i = 0; a[i] != -1; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 要添加一个元素，需要把新元素放在数组内首个-1的地方，然后把下一位改成-1
   int lastIndex = 0;
   while (a[lastIndex] != -1) {
       lastIndex++;
   }
   a[lastIndex] = 18;
   a[lastIndex + 1] = -1;

   // 将会输出 0 1 2 3 4 5 6 7 8 18
   for (int i = 0; a[i] != -1; i++) {
       cout << i << " ";
   }
   cout << endl;

   // 不过上述添加新元素的方法需要事先保证数组未满，如果数组已满：
   int lastIndex = 0;
   while (a[lastIndex] != -1) {
       lastIndex++;
   }
   a[lastIndex] = 18;
   a[lastIndex + 1] = -1; // lastIndex + 1 等于数组长度，发生越界，可能导致运行时报错、异常退出、或误修改其他变量
   ```

   (3) **无效化稀疏数组**：偶尔用到。**用一个固定不变的`int`表示数组长度，数组中有一个特殊值表示无效元素，所有不等于该值的元素，无论在特殊值的左边还是右边，都视为有效元素。**这种用法适合需要经常删除某些位于数组中间的元素的情况。遍历无效化稀疏数组时，需要从头遍历到尾，并且排除那些等于特殊值的元素。例如：

   ```c++
   int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
   const int length = 10;

   // 将会输出 0 1 2 3 4 5 6 7 8 9
   for (int i = 0; i < length; i++) {
       if (a[i] != -1) {
           cout << i << " ";
       }
   }
   cout << endl;

   // 要找到并且删去等于5的元素，只需要找到后把它设置为-1
   for (int i = 0; i < length; i++) {
       if (a[i] == 5) {
           a[i] = -1;
       }
   }

   // 将会输出 0 1 2 3 4 6 7 8 9
   for (int i = 0; i < length; i++) {
       if (a[i] != -1) {
           cout << i << " ";
       }
   }
   cout << endl;

   // 要添加新元素18，只需要找到第一个-1后把它设置为18，然后退出循环，防止给多个-1赋值
   for (int i = 0; i < length; i++) {
       if (a[i] == -1) {
           a[i] = 18;
           break;
       }
   }

   // 将会输出 0 1 2 3 4 18 6 7 8 9
   for (int i = 0; i < length; i++) {
       if (a[i] != -1) {
           cout << i << " ";
       }
   }
   cout << endl;

   // 不过上述添加新元素的方法需要事先保证数组未满
   // 如果数组已满，所有元素都不为-1，if中的语句将不会被执行，18将不会添加到数组中
   // 我们可以结合for循环的跳出判断，及时发现这种情况
   // 这里我们使用计数器跳出判断法，后面for循环部分会讲到
   int i;
   for (i = 0; i < length; i++) {
       if (a[i] == -1) {
           a[i] = 18;
           break;
       }
   }
   if (i == length) {
       cout << "数组已满，添加元素失败" << endl;
   }
   ```

   稀疏数组都是开发者自己与自己的约定，是数组的一些特殊用法，并不是C++提供的功能，学习时需要掌握其原理，知道为什么这样做。

4. **二维数组和多维数组**：以二维数组为例。二维数组就是数组的数组，也就是以数组为元素的数组。理解二维数组，需要从数组的数组性和指针性两方面来理解。

   (1) **二维数组的元素是一维数组，这些一维数组紧挨着存放在内存中。**因此，相邻两个一维数组是相连的，如果拥有第一个一维数组的尾元素指针，将其+1，即可得到第二个一维数组的首元素指针，这可以称为**二维数组的指针穿透**；如果拥有第一个一维数组的尾元素下标，将其+1，对第一个一维数组取这个下标内的元素，结果将是第二个一维数组的首元素，这可以称为**二维数组的下标穿透**。指针穿透和下标穿透不算越界，因为二维数组是一次性申请的一大块空间，在这一大块空间内，所有元素都是「一家人」，不存在跨界访问的限制。

   关于指针穿透和下标穿透，举一个例子：

   ```c++
   int a[3][4] = {
     1,  2,  3,  4, 
     5,  6,  7,  8, 
     9, 10, 11, 12
   }; // 每四个元素为一个一维数组，共三个一维数组

   // 下面用三种方法访问值为7的元素
   cout << a[1][2] << endl; // 输出7

   cout << a[0][1 * 4 + 2] << endl; // 输出7，下标穿透

   cout << *(*a + 1 * 4 + 2) << endl; // 输出7，指针穿透
   ```

   事实上，上述下标穿透和指针穿透的例子可以利用**下标运算恒等式**相互转换，后面会讲到。

   (2) **二维数组是指向第一个一维数组的指针，而第一个一维数组本身又是指向其第一个元素的指针**，因此二维数组是间接指向其第一个「元素的元素」的「指针的指针」。

   (3) **动态二维数组的特殊性**：如果`new`一个指针数组，然后对其中每个指针赋予一个`new`出来的一维数组，那么将会得到一个**动态二维数组**。**动态二维数组不是二维数组**，它只是普通的指针数组，虽然一般用法跟二维数组相似，但不满足二维数组的连续性，即**动态二维数组的相邻两个一维数组之间不一定相连**，因为它们不是一次性开出的大块空间，而是通过多次`new`运算开出来的多块空间。因此，**动态二维数组不具有指针穿透和下标穿透特性**，只能老老实实用两次下标运算访问其一维数组的元素。

5. **数组深拷贝和浅拷贝**：

   (1) 因为数组的本质是头指针常量，**数组不允许直接被赋值**。但数组作为指针，可以赋给其它指针，这称为**浅拷贝**；也可以把元素一个一个赋值给其它数组的元素，这称为**深拷贝**。

   (2) **浅拷贝**只是把自己的头指针共享了一份，让另一个指针也指向自己的存储区域。因此，浅拷贝后，两个指针将指向同一个数组空间，通过这两个指针对数组做修改是完全同步的，即一个指针修改了数组，也会影响另一个指针看到的数组内容，因此浅拷贝的两个指针**严格意义上不能看作两个数组**。

   (3) **深拷贝**是将自己的数组内容全部复制给另一个数组，让另一个数组里的内容和自己的数组一致，得到的两个数组内容一样，但互相独立，不再有关联，是**严格意义上的两个数组**。

### 6. 指针

指针是表示内存地址的一个数值，利用指针运算，我们可以在内存中跟踪某个特定位置的变量、在变量附近的内存空间内访问其它变量等等。

1. **指针的获得**：我们可以通过取地址运算`&`、数组名、字符串名、系统提供的句柄等途径来获得一个指针。例如：

   ```c++
   int a1 = 10;
   int* p1 = &a1; // 取地址运算，取a的地址赋给指针p

   int a2[10] = {}; // 数组的本质是指针常量，常量可以赋给变量
   int* p2 = a2; 

   char a3[10] = "hello"; // 字符串的本质是字符数组，也就是字符指针常量，同样可以赋给指针变量
   char* p3 = a3;
   ```

2. **常量指针**：常量指针是指向常量的指针，一般用于**把读取一块内存区域内容的权限转交给另一段程序，但又不想让这段程序修改该区域内容**的情况。常量指针的类型说明符是`const sometype *`或者`sometype const *`，其中`sometype`表示要指向的类型。

   (1) **常量指针是指向常量的指针，但不一定非要把一个常量的地址赋给它，也可以把变量的地址赋给它。**一种便于理解的解释是，系统会自动把变量的指针隐式转换为常量的指针，而不能把常量的指针隐式转换为变量的指针。这听起来似乎和「常量可以赋给变量，变量不能赋给常量」相反，但**常量指针**是**指向常量的指针**，**常量指针不是常量**，所以根本就不应该适用这句话。**更深层次的解释**需要结合类型的本质来看，所谓常量指针，变量指针，都只是C++层面的类型，而真正运行起来的时候，计算机里面存储的都只是一个整数地址，我们在C++层面所做的类型转换，从计算机层面来看都是徒劳无功，没有意义的。但这个「把变量指针转换成常量指针」的类型转换的意义恰恰停留在C++编译器层面上，因为常量指针解引用之后会成为常量类型，编译器不允许代码对常量类型做更改操作，所以正好满足了我们「既要把指针传给别人，又不想让他动里面的东西」的需求。

   (2) **常量指针广泛用于类库中，作为常数组、常字符串的载体存在着。**在C++标准库中，常量指针大量存在，一般规则是：**如果一个函数接受某个指针参数，且不需要改变指针指向的内容，那么这个参数就能写成常量指针；如果一个参数能写成常量指针，那么它一定要写成常量指针，否则会影响函数的使用。**为什么会影响函数的使用呢？原因还是在于上一点所说的「常量指针不能赋给变量指针」。如果你的程序拿到了一个常量指针，你需要把它传给函数进行使用，但函数接受的是变量指针，那就无法赋值，出现编译错误。初学者暂且可以忽略这个问题，但若要深入使用C++进行开发，务必注意把函数中能定义成常量指针的都写成常量指针。

3. **指针常量**：指针常量又称为常指针，它**是一个指针**，同时也**是一个常量**，即指针常量所指的地址不能被改变，而指向的区域内容可以改变，不受影响。这跟常量指针正好相反。指针常量的类型说明符是`sometype * const`。指针常量满足「常量可以赋给变量，变量不能赋给常量」的正常规则，但指针常量其实很少被用到，用处不大。

4. **指针的赋值**：指针有两种赋值：直接给指针本身赋予一个地址，可以让指针重新指向该地址处的变量，例如`int* p = &a; p = &b;`；对指针解引用再赋值，可以改变指针所指向的变量的值，例如`int* p = &a; *p = b;`。第一个例子中，`p`指向了新的变量`b`，不再指向`a`；第二个例子中，我们通过`p`把`a`的值改成和`b`的值相同。

5. **指针的移动**：指针作为一个地址，可以进行一定的运算，即指针的移动。首先介绍`sizeof`运算。`sizeof`是求某个类型或某个变量所占存储空间的运算符，它计算的结果是以存储字长为单位的。对于普通计算机，存储字长都是1字节，因此`sizeof char`的结果一定为1；同理，32位机上`sizeof int`的结果是4。恰巧计算机的地址也是以存储字长为单位的，在内存中移动1字节，地址就加1或减1。因此如果我们有一个`int`数组，知道了第一个元素的地址（这里假设不适用指针，用整数类型表示地址），那么对它`+4`就得到第二个元素的地址。这里我们就要注意到相邻的`int`和`int`之间，地址相差4个存储字长。但C++的指针会自动帮我们计算这个类型的长度，原来需要`+4`的，使用指针类型只需要`+1`即可。据此我们可以归纳为：**一般地，对于`sometype *`类型的指针`p`，`p + 1`就是指向相邻的下一个`sometype`类型变量的指针；对应地，`(int)(p + 1) - (int)p`的值一定等于`sizeof sometype`的值。**另外需要注意的是，指针`p`本身没有移动，而是加法的结果`p + 1`指向了下一个元素。如果要指针本身进行移动，可以用`++`、`--`、`+=`、`-=`、或者普通的赋值运算`p = p + 1`等，前提是`p`本身**不是指针常量**。

6. **无效指针和空指针**：**无效指针**是指那些**所指的地址不在当前程序能访问的内存范围内**、以至于不能从对应的地址取出变量的指针。值为0（即`NULL`）的无效指针称为**空指针**；值不为0的无效指针称为**野指针**。对无效指针解引用会导致程序异常退出。因为无效指针的值不唯一，我们无法判断一个指针是不是无效指针，所以我们一般把**不得不暂时设置为无效指针的指针**设为**空指针**，以便日后判断。这也是开发者自己与自己的约定，是一个良好的开发习惯。具体包括如下三条规则：

   (1) 如果定义了指针，且暂时不打算指向有效变量，那么立即将其赋`NULL`；

   (2) `delete`一块内存空间之后，立即将指向这块内存空间的所有指针赋`NULL`；

   (3) **只要遵循上面两条规则，我们就可以认为我们程序里的所有无效指针都是空指针了**，因此就可以通过判断指针是否为空，来判断指针是否无效。若指针非空，则可以放心大胆地解引用（或取下标）。

   我们可以将以上三条视为一个协议，前两条是我们的义务，第三条是我们因为履行义务而获得的权利。如果前两条没有被认真履行，那么第三条将不会成立。

### 7. 引用

引用是C++对**指针常量**的一个封装，使用引用可以让多个「变量」方便地共享同一块内存空间，而不需要定义指针、进行解引用等操作。对于初学者而言，引用可以视为变量的**别名**。

引用只能代替**指针常量**而不能代替**指针变量**，原因在于：引用在被赋值的时候，始终会赋值给自己引用的变量；而指针既可以通过解引用，给它指向的对象赋值，又可以不解引用，给指针所指的地址赋值。

1. **引用的初始化**：引用类型一经定义必须初始化，引用的初始化就是让它引用（指向）一个变量。例：

   ```c++
   int a = 10;
   int& aRef = a;
   ```

   注意，引用只能引用有内存空间的变量或常量，不能引用字面量，这是因为字面量不占用内存空间。习惯上常常会说成「引用不能引用常量」，但这种说法是不正确的，不能引用的是字面量，而有内存空间的常量可以被引用。

2. **引用的赋值**：引用被赋值时，值会被赋给它所引用的变量，而不会让它引用新的变量。这是因为**引用的本质是指针常量**。注意，**引用的初始化不属于引用的赋值**。

需要了解的是，**几乎所有编程语言都倾向于让引用只有一种赋值方式，因为类似于C++指针的两种赋值会非常不便于使用。既然引用只有一种赋值，那么引用将无法完全代替指针，只能要么代替常量指针（只能赋地址），要么代替指针常量（只能赋内容）。**C++的引用是**指针常量**的替代，而大多数现代编程语言（例如Java）的引用是对**常量指针**的替代。在这些语言中，所有变量实质上都是常量，变量本身所包含的内容是不可变的，只有引用是可变的；对引用赋值是让它引用新的对象，而不能改变原来引用的对象的值。这一点一定要在学习Java基础时弄明白，否则会遇到很多奇怪的问题。

### 8. 字符串（C风格）

字符串的本质是一个变界稀疏数组。在此基础上，C语言对字符串处理提供了一些方便：

1. **字符串字面量**：用半角双引号`""`括起来的一串字符构成一个字符串字面量。

   (1) **字符串字面量的转义**：如果需要在字符串里面包含一个半角双引号`"`，需要用`\"`代替；而单引号则可以直接写`'`；其它规则跟字符字面量的转义规则相同。

   (2) **字符串字面量自动分配空间**：对于字符串字面量，程序会自动开好同等长度的空间，放入该字符串，并返回其头指针，因此我们可以放心地用字符串字面量初始化字符指针，而不需要担心没有数组空间来存储这个字符串。**一个例外是**，字符串字面量用于初始化字符数组时，程序不会为字面量单独开辟空间，而是直接把字符串放入需要初始化的数组中。

   (3) **自动分配空间的**字符串字面量本质上是**指向常量空间的字符指针常量**，作为稀疏数组，它同时也是一个**填满的稀疏数组**。这句话比较绕口，需要仔细理解。首先有一个前提：**自动分配空间的**字符串字面量才适用于此规则，如果是用字符串字面量初始化字符数组，则不适用于此规则；其次，**自动分配空间的**字符串字面量是**指向常量空间的字符指针常量**，虽然它本身是只是指针常量`char* const`类型，并不是一个常量指针，但它指向一块特殊的常量空间，因此也不能改变字符串里面的内容，如果改变里面的内容，不会发生编译错误，但是会导致运行时异常（在最新gcc中，对这个问题做了修改，把自动分配空间的字符串字面量正式改成了常量指针，不再支持赋值给变量指针）；最后，它也是一个**填满的**稀疏数组，这就意味着它不能存放比原来的值更长的内容。例：

   ```c++
   char* a = "hello"; // 直接把字符串字面量赋值给字符指针，因此使用自动分配空间
   a[1] = 'a'; // 错误，自动分配的空间是常量空间，修改内容可能导致运行时错误
   a[10] = 's'; // 错误，自动分配的空间是常量空间，修改内容可能导致运行时错误；即使能修改，a的空间也只有6个单位，a[10]会越界
   cin >> a; // 错误，cin的本质是把a作为字符数组，对a的每个元素赋值，而不是让a指向新的空间，所以a依然指向自动分配的空间；而自动分配的空间是常量空间，不能改变内容

   char b[] = "hello"; // 这里不是自动分配空间，而是使用自己定义的数组空间，数组长度自动初始化为6
   b[1] = 'a'; // 正确，自己定义的数组空间没有限制，可以修改
   b[10] = 's'; // 错误，b的数组长度只有6，b[10]会越界
   cin >> b; // 正确，但只能输入不超过5个ASCII字符

   char c[100] = "hello";
   c[1] = 'a'; // 正确
   c[10] = 's'; // 正确，但由于字符串到\0就截止了，不会对字符串内容有影响
   cin >> c; // 正确，可以输入不超过99个ASCII字符

   // 加深理解：以上区别并不是数组和指针之间的区别，而是字符串字面量到底被赋给谁的区别。
   // 因为如果把第一个例子改成这样，同样是在「用指针」，就完全没问题了：
   char d[100] = "hello";
   char* e = d;
   e[1] = 'a'; // 正确
   e[10] = 's'; // 正确
   cin >> e; // 正确
   ```

   总结：虽然字符指针也是数组，字符数组也是数组，但是因为用字符串字面量初始化它们的时候存在一些区别，他们的用途也就有了差异。理解了上面几个例子，我们就清楚什么时候可以用字符指针表示字符串，什么时候可以用字符数组表示字符串了。

## 三、运算符和表达式

### 1. 优先级和结合性

C++运算符优先级表需要熟记：

| 口诀      | 运算符                                      |
| ------- | ---------------------------------------- |
| 类名空间作用域 | 指定要调用函数的命名空间或类名，例如`a.A::fun()`           |
| 括号成员和下标 | 括号调用`()` 取成员`.` 解引用取成员`->` 下标运算`[]`      |
| 后置转换尖又圆 | 后置`++` `--` 强制转换 `xxx_cast<type>` `(type)` |
| 前置增删求大小 | 前置`++` `--` `new` `delete` `sizeof`      |
| 反非容址正负针 | 取反`~` 非`!` 解引用`*` 取地址`&` 正负号`+` `-` 指针成员 `.*` `->*` |
| 乘除加减移比较 | 四则`*` `/` `+` `-` 移位`<<` `>>` 大小比较`<` `<=` `>=` `>` |
| 相等按位与异或 | 相等不等比较`==` `!=` 按位与`&` 按位异或`^` 按位或`︳`    |
| 与或三赋抛逗号 | `&&` `‖` 三元 `?:` 各种赋值 `+=` `-=` `=`等 抛异常`throw` 逗号运算符`,` |

表中不是一行对应一个优先级，只是为了一行对应一句口诀，有很多多行的运算符是同级的，也有很多同一行的运算符是不同级的，口诀只保证前面的运算符优先级不低于后面的，但这个口诀对于很多情况的判断已经很好用了。如果去掉一些C++特有的运算符，同样适用于C、Java、JS等语言。

**运算符结合性**是指，同一优先级的多个运算符相串联时，按照什么顺序计算。例如四则运算是左结合的，也就是说当乘除运算发生串联、或者加减运算发生串联时，按照从左到右的顺序计算。C++的结合性很好记忆，对于一元运算符，前置的都是右结合，后置的都是左结合；二元运算符除赋值外，都是左结合；三元、赋值运算符都是右结合；对于那些`new` `delete`之类的特殊运算符，视为一元运算符处理。

### 2. 四则运算

四则运算 `+` `-` `*` `/` `%` 不做详细介绍，只需要记住一点：如果两个操作数都是整数类型，四则运算的结果也是整数类型；如果结果不是整数，就自动舍去小数部分变成整数类型，例如`5 / 2 == 2`。另外要注意浮点数运算的误差，例如`0.1 + 0.2 == 0.30000000000000004`，而不是等于`0.3`。

### 3. 下标运算

下标运算`[]`是指针的运算，本质是指针的移动。下标运算并不是数组的特性，即使中括号是数组的类型说明符。

**下标运算恒等式**：`a[b] == *(a + b)`，其中`*`为解引用运算符。只要`a`和`b`有一个为指针，另一个为整数，`a[b]`即成立，但能否成功解引用还要看得到的地址是否有效。

### 4. 自增自减

自增自减运算`++` `--`有前后置之分，区别有三：

1. 前置自增自减返回增减后的值，后置自增自减返回增减前的值；
2. 前置自增自减返回左值，即可以被赋值，例如`++a = 2;`；后置自增自减返回右值，不可以被赋值；
3. 运算符重载时，前置自增自减运算有一个参数；后置自增自减运算有两个参数，第二个参数`int`是一个伪参数，没有实际用途，只是为了在函数签名上与前置运算进行区分。**当然，如果重载为成员函数，第一个参数变成了`this`就省略了，此时前置看起来没有参数，后置看起来有一个参数。**

如果熟悉运算符重载，可以推断出自增自减运算的内部实现方式（以自增为例）：

```c++
// 前置自增运算
template <typename T>
T& operator++ (T& t) {
    t = t + 1;
    return t;
}

// 后置自增运算，其返回值类型、参数个数、返回的值都与前置不一样
template <typename T>
T operator++ (T& t, int) {
    T temp = t;
    t = t + 1;
    return temp;
}
```

### 5. 类型转换 

类型转换分为静态转换`static_cast`、动态转换`dynamic_cast`、去常量转换`const_cast`、再解释转换`reinterpret_cast`四种。圆括号转换`()`是静态转换的C语言写法。

1. **静态转换`static_cast<类型>(变量)`**：可以在基本类型之间、基类和子类之间进行无条件的转换，允许基类转换成子类（不安全），但不能在无关类之间进行转换，也不能强制去除`const`常量修饰符；
2. **动态转换`dynamic_cast<类型>(变量)`**：可以在基类和子类之间进行安全的转换，**要求基类必须有虚函数**。如果对象不属于要转换到的类型（例如基类转换成子类），将会返回空指针；
3. **去常量转换`const_cast<类型>(变量)`**：可以强行把常量转换成变量，去掉常量的限制，不建议使用；
4. **再解释转换`reinterpret_cast<类型>(变量)`**：不对内存数据做修改，只是把同一个变量解释成另外一种类型，例如在读写二进制文件时，把各种类型的对象解释成字符串并写入文件，再把文件里的「字符串」读取出来并解释成正确的类型。

### 6. new和delete

`new`：动态创建一块空间并初始化为某个类型。`new`有三种格式：

1. `new sometype`：动态创建一个`sometype`类型的变量（如果是类类型，调用默认构造函数），返回其指针；
2. `new sometype[length]`：动态创建一个`length`长度的`sometype`类型的数组，返回其头指针；
3. `new someclass(parameter1, parameter2, ...)`：动态创建一个`someclass`类的对象，并调用对应的构造函数，返回其指针。

对应地，`delete`有两种格式：

1. `delete ptr`：回收指针`ptr`所指向的单个空间，放弃对这块空间的控制权；
2. `delete[] ptr`：回收指针`ptr`所指向的数组空间，放弃对这块空间的控制权；

**注意**：

1. `delete`不是删除指针，而是回收指针所指向的空间。`delete`操作过后，指针仍指向原来的位置，但程序不再对此位置拥有控制权，因此指针变为野指针，此时如果还需要使用这个指针，应当立即将其赋`NULL`；
2. `delete`的数量应该严格等于所申请的空间数量，而不是等于指针数量，例如如果多个指针指向同一个空间，只需要对其中一个进行`delete`即可。
3. 对于数组空间，必须`delete []`，而不是只有`delete`。
4. `new`操作声明的内存位于堆空间上，堆空间的内存不会随作用域结束自动回收，必须手动使用`delete`进行回收。必须保证每个`new`操作都有对应的`delete`。

### 7. 二进制运算

1. 按位取反`~`：一元运算，把基本类型的变量视为二进制整数，逐位取反，即1变成0，0变成1，结果按二进制读成整数；
2. 按位与`&`：二元运算，把两个基本类型变量视为二进制整数，对应位取「与」运算，即两者都是1，结果为1，否则结果为0，结果按二进制读成整数；
3. 按位或`|`：二元运算，把两个基本类型变量视为二进制整数，对应位取「或」运算，即两者都是0，结果为0，否则结果为1，结果按二进制读成整数；
4. 按位异或`^`：二元运算，把两个基本类型变量视为二进制整数，对应位取「异或」运算，即两者相同，结果为0，两者不同，结果为1，结果按二进制读成整数；
5. 左右移`<<` `>>`：二元运算，将左边的操作数视为二进制整数，右边的操作数为移位的位数；若左边为有符号数，进行**算数左/右移**；若左边为无符号数，进行**逻辑左/右移**。算数左/右移和逻辑左/右移的概念将会在计算机组成中学到。

### 8. 短路运算

1. 逻辑与`&&`：先计算左边值，若左边为假，右边不再计算，结果为假；若左边为真，计算右边，右边为假，结果为假，右边为真，结果为真；
2. 逻辑或`||`：先计算左边值，若左边为真，右边不再计算，结果为真；若左边为假，计算右边，右边为真，结果为真，右边为假，结果为假；
3. 三元运算`?:`：先计算左边值，若左边为真，计算中间的值作为结果；若左边为假，计算右边的值作为结果。三元运算优先级很低，若放在四则运算和输入输出内部，三元运算外面一般要套括号。

### 9. 逗号运算符

C++中一般所见的逗号（如声明多个变量、函数参数列表、数组初始化列表等）都**不是**逗号运算符，只有脱离上述语境才是逗号运算符。逗号运算符会按顺序求每一部分的值，然后以最后一部分的值作为结果。例如：

```c++
// 改编自 C++ 期末考题
class A {
private:
    int x;
    int y;
  
    A(int x, int y) {
        this->x = x;
        this->y = y;
    }
  
    A() {
        this->x = 0;
        this->y = 0;
    }
};

A* p = new A[3, 4];
cout << p->x << endl;
```

此处`new A[3, 4]`平时没见过，考试时有同学问老师是不是打错了应该是圆括号，老师明确说试卷没有错误，所以考虑到应该是逗号运算符。逗号运算符按顺序求解每一个值，然后将最后一个值`4`作为结果，因此这里其实是`new A[4]`，是创建了一个含有4个A对象的数组，调用各自的默认构造函数，因此`p`指针指向数组第一个元素，元素里的`x`值为`0`，输出就是`0`。

### 10. 运算符重载

运算符重载主要有两种：重载为普通函数、重载为成员函数。

1. **重载为普通函数**即把运算符重载写在全局作用域下，参数一个不少，从客观的角度执行需要做的操作；
2. **重载为成员函数**即把运算符重载写在类里面，前提是这个类必须是这个运算符的第一个参数的类型，然后第一个参数作为`this`就可以省略，从第一个参数的主观角度来做操作。

运算符重载还需要注意以下几点：

1. 注意返回值的类型，是值还是引用；
2. 可能会用到模板函数；
3. **如果在模板类内重载运算符，需要把函数的实现写到头文件中**，无法做分离，这是C++的一个局限；
4. 如果在类外重载，可能会用到友元函数；
5. 运算符重载不会改变原来运算符的优先级和结合性。例如`iostream`中的`<<` `>>`运算符仍保持左移右移运算符的结合性。

## 四、流程控制

### 1. 分支语句if

1. **非贪心原则**：`if`语句若不加大括号，只把`if`后第一个完整语句视为`if`之内的语句，其余视为`if`外的语句；`else`也同理。**务必注意：一个分号`;`不会做任何事情，但也是一个语句。**
2. **就近原则**：`else`前面的`if`若不加大括号，`else`将会跟前面最近的、且没有跟其它`else`配对过的`if`配对；
3. 为了防止出现以上情况引起误解，代码规范要求我们给所有的`if`和`else`添加大括号。

### 2. 多分支语句switch

1. **`case`是起点不是终点**：`switch`的表达式跟某一个`case`值相等，只会让程序跳到这个`case`标签处开始执行，并不会执行到下个标签处就停止，永远记住在每一种情况结束的地方加`break`；
2. **合并标签**：利用第1条的特性，可以把多种情况的`case`连起来写，中间不加`break`，这样两种情况都会从同一处开始执行；
3. **考虑所有情况**：代码规范告诉我们`switch`要考虑到所有可能的情况，如果没有覆盖所有的`case`，最好加`default`情况做默认处理。

### 3. 循环语句for、while、do...while

1. `if`中的非贪心原则同样适用于循环语句，因此循环语句也要养成添加大括号的习惯；

2. **`for`的实质**：`for`循环实质上可以等价转换为一个`while`循环。当你无法理解一些写的比较复杂的`for`循环时，可以利用此性质将其转换成`while`循环来看：

   ```c++
   // S1代表一个语句；S2代表一个布尔表达式；S3代表一个语句；S4代表一个或多个语句。
   for (S1; S2; S3) {
       S4;
   }
   // 等价于
   { // 这个大括号用于限制S1中新声明变量（如果有）的作用域，这样跟for循环完全等价
       S1;
       while (S2) {
           S4;
           S3;
       }
   }
   ```

   一个具体例子：

   ```c++
   for (int i = 0; i < 10; i++) {
       cout << i << endl;
   }
   // 等价于
   {
       int i = 0;
       while (i < 10) {
           cout << i << endl;
           i++;
       }
   }
   ```

3. **`for`循环的计数特性**：

   (1) `for`循环没有被`break`、`return`打断，称为**正常退出**，否则称为**非正常退出**；

   (2) 若`for`循环将要正常退出，最后一次循环进行时，计数变量应保持**刚好满足循环条件的最后一个值**；

   (3) 若`for`循环正常退出，且退出后计数变量还存在，计数变量应保持**刚好不满足循环条件的第一个值**；

   (4) 若`for`循环非正常退出，且退出后计数变量还存在，计数变量应保持**非正常退出时的计数变量的值**。

   例：

   ```c++
   int i;
   for (i = 0; i < 10; i++) {
       // 什么也不做
   }
   cout << i << endl; // 应输出10而不是9

   for (i = 0; i < 10; i++) {
       if (i == 5) break;
   }
   cout << i << endl; // 应输出5
   ```

   ​

4. **`for`的完全性/存在性判断**：`for`循环常常用于判断每一次循环是否**全部满足**某个条件，或者是否**至少有一次循环满足**某个条件，这两种情况分别称为`for`循环的**完全性判断**和**存在性判断**。

   事实上，从数理逻辑层面来讲，完全性判断和存在性判断是对立统一的，判断一个条件**完全成立**，也就是判断这个条件**不存在不成立**；反之，判断一个条件**存在成立**，也就是判断这个条件**不完全不成立**。换句话说，判断**一个命题**的**存在性**和判断**其否定**的**完全性**是可以同时进行的。

   因此，我们在这里提供一系列方法，每一种方法都可以**同时判断**命题`S`的存在性和其否定`!S`的完全性。

   需要注意的是，在实际应用中，`S`往往是与循环计数变量`i`有关的逻辑表达式，而不是单个布尔变量。

   (1) **插旗判断**：这是最一般的判断方法，效率最低，没有做任何优化。主要思路是，用一个布尔变量表示命题`S`是否存在成立，起初我们假设它为`false`，当我们在循环中发现命题`S`存在成立时，设置它为`true`。循环结束后，根据这个布尔变量的值来判断结果：若为`false`，表示`S`不存在成立，`!S`完全成立；若为`true`，表示`S`存在成立，`!S`不完全成立。例：

   ```c++
   bool flag = false;
   for (int i = 0; i < 10; i++) {
       if (S) {
           flag = true;
       }
   }
   if (flag) {
       cout << "S存在成立" << endl;
       cout << "!S不完全成立" << endl;
   } else {
       cout << "S不存在成立" << endl;
       cout << "!S完全成立" << endl;
   }
   ```

   (2) **插旗跳出判断**：在插旗判断中，若发现`S`存在成立，结论已定，可以立即用`break`退出循环，省去了后续判断的时间。

   ```c++
   bool flag = false;
   for (int i = 0; i < 10; i++) {
       if (S) {
           flag = true;
           break;
       }
   }
   if (flag) {
       cout << "S存在成立" << endl;
       cout << "!S不完全成立" << endl;
   } else {
       cout << "S不存在成立" << endl;
       cout << "!S完全成立" << endl;
   }
   ```

   (3) **计数器跳出判断**：在插旗跳出判断中，只要`S`存在成立，我们就会`break`，让循环非正常退出。在此基础上，根据`for`循环计数特性，我们已经无需使用`flag`来判断是否非正常退出，只需要让计数变量的作用域覆盖到循环之外，在循环结束后判断计数变量是否满足循环条件。若计数变量不满足循环条件，就是正常退出；满足循环条件，则是非正常退出。

   ```c++
   int i;
   for (i = 0; i < 10; i++) {
       if (S) {
           break;
       }
   }
   if (i < 10) {
       cout << "S存在成立" << endl;
       cout << "!S不完全成立" << endl;
   } else { // 即 i == 10
       cout << "S不存在成立" << endl;
       cout << "!S完全成立" << endl;
   }
   ```

   (4) **原地判断**：在计数器跳出判断中，我们还需要把计数变量的作用域提到循环之外，这样也不够方便。我们现在考虑一种特殊情况，**如果判断完是否成立之后，当前函数不需要做其他事情即可结束**，那么我们有更快速的方法：

   ```c++
   for (int i = 0; i < 10; i++) {
       if (S) {
           cout << "S存在成立" << endl;
           cout << "!S不完全成立" << endl;
           return;
       }
   }
   cout << "S不存在成立" << endl;
   cout << "!S完全成立" << endl;
   ```

   或者，**如果当前函数不是用来输出，而是要直接返回一个布尔值，来表示`S`是否存在成立**，那么代码会变得更简单：

   ```c++
   for (int i = 0; i < 10; i++) {
       if (S) {
           return true;
       }
   }
   return false;
   ```

   以上四种方法就是`for`循环中常用的一些完全性/存在性判断方法。请注意这些方法之间有哪些共同的特性：比如**每一种方法的`for`中都只有`if`，没有`else`**，因为你**至少要留一个让循环继续进行的情况**，而不是让每一种情况都导致循环非正常退出。

5. `for`循环的三个字句`S1` `S2` `S3`都是可省略的：省略S1表示没有初始操作；省略S2表示循环始终继续，直到`break`才退出；省略S3表示每一次循环结束后不需要做别的事情。当然，省略S1或S2时，分号要留下来。常见的死循环写法`for (;;) {`就是这么来的（另一个写法是`while (true) {`或`while (1) {`）。**另外值得一提的是**，在设计算法时，如果我们暂时只知道要写个循环，但还没确定循环怎么开始、条件如何、如何步进，那么可以先写一个`for (;;) {`或者`while (true) {`，然后再逐渐填充主干。

6. `do..while`的一个注意点：`do { ... } while ( ... );`最后千万记得加分号。

7. `do..while`跟其它循环不一样的地方就是，它的第一次循环不需要进行判断，无条件进行；进行一次之后再做判断是否继续。

8. **生产者-消费者循环**：这一名字起源于设计模式中的**生产者-消费者模式**。我们熟知的`while`循环适用于在每次循环前做判断，`do..while`适用于在每次循环后做判断；而生产者-消费者循环是一种常见的特殊循环模式，一般用于读文件、读用户输入等情形，其特点是**在循环中间做判断**。C++以及绝大多数高级语言没有提供在循环中间做判断的写法，因此我们需要用`while`来模拟。。它的写法比较特殊：它需要在循环之前和循环内部各写一次「生产」语句。例：

   ```c++
   // 每次读取用户输入的整数，以特殊值-1结尾，求平均值。
   // 简单的生产者-消费者模式，生产者是用户的输入，消费者是累加器进行累加。

   // 初始化
   int sum = 0;
   int count = 0;
   int current;

   // 首次生产
   cout << "请输入第" << count + 1 << "个数，或者输入-1结束：";
   cin >> current;

   // 判断上次生产的结果能否被消费
   while (current != -1) {
     
     	// 消费
       count++;
       sum += current;
       
       // 再次生产
       cout << "请输入第" << count + 1 << "个数，或者输入-1结束：";
       cin >> current;
   }

   // 生产消费循环结束，计算平均值
   if (count == 0) {
       cout << "你没有输入数字！"
   } else {
       double average = (double)sum / count;
       cout << "平均值为：" << average << endl;
   }
   ```

   这是一个典型的生产者-消费者模式的例子，整个程序的执行顺序就是：首次生产-判断能否消费-消费-再次生产-判断能否消费-消费-……直到某一次生产出来的值为-1，不能消费，循环结束，计算平均值。我们注意到，**「首次生产」和「再次生产」这里的两组语句是完全一样的**（首次生产时`count + 1`一定为1，但为了和后面保持代码完全一致，以便我们日后维护时能快速看出这两处是一样的代码，还是写成了`count + 1`）。其实如果「首次生产」和「再次生产」的代码很多，也可以用另一种写法把他们合并：

   ```c++
   // 每次读取用户输入的整数，以特殊值-1结尾，求平均值。
   // 简单的生产者-消费者模式，生产者是用户的输入，消费者是累加器进行累加。

   // 初始化
   int sum = 0;
   int count = 0;
   int current;

   // 这里不做判断，无条件继续循环
   while (1) {
       
       // 生产
       cout << "请输入第" << count + 1 << "个数，或者输入-1结束：";
       cin >> current;
     
       if (current == -1) break; // 在循环中间判断
     
     	// 消费
       count++;
       sum += current;
   }

   // 生产消费循环结束，计算平均值
   if (count == 0) {
       cout << "你没有输入数字！"
   } else {
       double average = (double)sum / count;
       cout << "平均值为：" << average << endl;
   }
   ```

   这样也是可以接受的写法，但似乎多数程序员还是偏爱前一种，因为前一种在较大的算法中往往更清晰易懂；但如果生产的语句确实多而复杂，还是建议用第二种以避免代码重复。

## 五、函数

声明和实现

函数重载

默认参数

静态变量

传值与传引用

内联函数

函数指针

递归

## 六、宏

ifndef/define/endif

define

typedef

宏函数

## 七、异常处理

抛出异常

捕捉异常

捕捉列表

异常重抛

## 八、常见库函数的使用

cstdlib

ctime

cmath

cstring

iostream

iomanip

fstream

string

## 九、结构体和枚举

结构体

枚举

## 十、类和对象

声明和实现

构造与析构

继承

多态

初始化列表

访问控制

友元

静态成员

模板

## 附一、算法基础

复杂度与渐进分析

搜索算法

排序算法

## 附二、数据结构基础

连续线性表

链表

栈

队列

图和树

## 附三、计组相关

编码方式

编译期和运行期

类型的物理本质

堆空间、栈空间和内存管理